"use strict";
var _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	return typeof obj
} : function (obj) {
	return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
};
!function ($, window, document, undefined) {
	function Owl(element, options) {
		this.settings = null, this.options = $.extend({}, Owl.Defaults, options), this.$element = $(element), this._handlers = {}, this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._widths = [], this._invalidated = {}, this._pipe = [], this._drag = {
			time: null,
			target: null,
			pointer: null,
			stage: {start: null, current: null},
			direction: null
		}, this._states = {
			current: {},
			tags: {initializing: ["busy"], animating: ["busy"], dragging: ["interacting"]}
		}, $.each(["onResize", "onThrottledResize"], $.proxy(function (i, handler) {
			this._handlers[handler] = $.proxy(this[handler], this)
		}, this)), $.each(Owl.Plugins, $.proxy(function (key, plugin) {
			this._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this)
		}, this)), $.each(Owl.Workers, $.proxy(function (priority, worker) {
			this._pipe.push({filter: worker.filter, run: $.proxy(worker.run, this)})
		}, this)), this.setup(), this.initialize()
	}

	Owl.Defaults = {
		items: 3,
		loop: !1,
		center: !1,
		rewind: !1,
		checkVisibility: !0,
		mouseDrag: !0,
		touchDrag: !0,
		pullDrag: !0,
		freeDrag: !1,
		margin: 0,
		stagePadding: 0,
		merge: !1,
		mergeFit: !0,
		autoWidth: !1,
		startPosition: 0,
		rtl: !1,
		smartSpeed: 250,
		fluidSpeed: !1,
		dragEndSpeed: !1,
		responsive: {},
		responsiveRefreshRate: 200,
		responsiveBaseElement: window,
		fallbackEasing: "swing",
		slideTransition: "",
		info: !1,
		nestedItemSelector: !1,
		itemElement: "div",
		stageElement: "div",
		refreshClass: "owl-refresh",
		loadedClass: "owl-loaded",
		loadingClass: "owl-loading",
		rtlClass: "owl-rtl",
		responsiveClass: "owl-responsive",
		dragClass: "owl-drag",
		itemClass: "owl-item",
		stageClass: "owl-stage",
		stageOuterClass: "owl-stage-outer",
		grabClass: "owl-grab"
	}, Owl.Width = {Default: "default", Inner: "inner", Outer: "outer"}, Owl.Type = {
		Event: "event",
		State: "state"
	}, Owl.Plugins = {}, Owl.Workers = [{
		filter: ["width", "settings"], run: function () {
			this._width = this.$element.width()
		}
	}, {
		filter: ["width", "items", "settings"], run: function (cache) {
			cache.current = this._items && this._items[this.relative(this._current)]
		}
	}, {
		filter: ["items", "settings"], run: function () {
			this.$stage.children(".cloned").remove()
		}
	}, {
		filter: ["width", "items", "settings"], run: function (cache) {
			var margin = this.settings.margin || "", grid = !this.settings.autoWidth, rtl = this.settings.rtl,
				css = {width: "auto", "margin-left": rtl ? margin : "", "margin-right": rtl ? "" : margin};
			!grid && this.$stage.children().css(css), cache.css = css
		}
	}, {
		filter: ["width", "items", "settings"], run: function (cache) {
			var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin, merge = null,
				iterator = this._items.length, grid = !this.settings.autoWidth, widths = [];
			for (cache.items = {
				merge: !1,
				width: width
			}; iterator--;) merge = this._mergers[iterator], merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge, cache.items.merge = 1 < merge || cache.items.merge, widths[iterator] = grid ? width * merge : this._items[iterator].width();
			this._widths = widths
		}
	}, {
		filter: ["items", "settings"], run: function () {
			var clones = [], items = this._items, settings = this.settings, view = Math.max(2 * settings.items, 4),
				size = 2 * Math.ceil(items.length / 2),
				repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0, append = "",
				prepend = "";
			for (repeat /= 2; 0 < repeat;) clones.push(this.normalize(clones.length / 2, !0)), append += items[clones[clones.length - 1]][0].outerHTML, clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, !0)), prepend = items[clones[clones.length - 1]][0].outerHTML + prepend, repeat -= 1;
			this._clones = clones, $(append).addClass("cloned").appendTo(this.$stage), $(prepend).addClass("cloned").prependTo(this.$stage)
		}
	}, {
		filter: ["width", "items", "settings"], run: function () {
			for (var rtl = this.settings.rtl ? 1 : -1, size = this._clones.length + this._items.length, iterator = -1, previous = 0, current = 0, coordinates = []; ++iterator < size;) previous = coordinates[iterator - 1] || 0, current = this._widths[this.relative(iterator)] + this.settings.margin, coordinates.push(previous + current * rtl);
			this._coordinates = coordinates
		}
	}, {
		filter: ["width", "items", "settings"], run: function () {
			var padding = this.settings.stagePadding, coordinates = this._coordinates, css = {
				width: Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + 2 * padding,
				"padding-left": padding || "",
				"padding-right": padding || ""
			};
			this.$stage.css(css)
		}
	}, {
		filter: ["width", "items", "settings"], run: function (cache) {
			var iterator = this._coordinates.length, grid = !this.settings.autoWidth, items = this.$stage.children();
			if (grid && cache.items.merge) for (; iterator--;) cache.css.width = this._widths[this.relative(iterator)], items.eq(iterator).css(cache.css); else grid && (cache.css.width = cache.items.width, items.css(cache.css))
		}
	}, {
		filter: ["items"], run: function () {
			this._coordinates.length < 1 && this.$stage.removeAttr("style")
		}
	}, {
		filter: ["width", "items", "settings"], run: function (cache) {
			cache.current = cache.current ? this.$stage.children().index(cache.current) : 0, cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current)), this.reset(cache.current)
		}
	}, {
		filter: ["position"], run: function () {
			this.animate(this.coordinates(this._current))
		}
	}, {
		filter: ["width", "position", "items", "settings"], run: function () {
			var inner, outer, i, n, rtl = this.settings.rtl ? 1 : -1, padding = 2 * this.settings.stagePadding,
				begin = this.coordinates(this.current()) + padding, end = begin + this.width() * rtl, matches = [];
			for (i = 0, n = this._coordinates.length; i < n; i++) inner = this._coordinates[i - 1] || 0, outer = Math.abs(this._coordinates[i]) + padding * rtl, (this.op(inner, "<=", begin) && this.op(inner, ">", end) || this.op(outer, "<", begin) && this.op(outer, ">", end)) && matches.push(i);
			this.$stage.children(".active").removeClass("active"), this.$stage.children(":eq(" + matches.join("), :eq(") + ")").addClass("active"), this.$stage.children(".center").removeClass("center"), this.settings.center && this.$stage.children().eq(this.current()).addClass("center")
		}
	}], Owl.prototype.initializeStage = function () {
		this.$stage = this.$element.find("." + this.settings.stageClass), this.$stage.length || (this.$element.addClass(this.options.loadingClass), this.$stage = $("<" + this.settings.stageElement + ">", {class: this.settings.stageClass}).wrap($("<div/>", {class: this.settings.stageOuterClass})), this.$element.append(this.$stage.parent()))
	}, Owl.prototype.initializeItems = function () {
		var $items = this.$element.find(".owl-item");
		if ($items.length) return this._items = $items.get().map(function (item) {
			return $(item)
		}), this._mergers = this._items.map(function () {
			return 1
		}), void this.refresh();
		this.replace(this.$element.children().not(this.$stage.parent())), this.isVisible() ? this.refresh() : this.invalidate("width"), this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass)
	}, Owl.prototype.initialize = function () {
		var imgs, nestedSelector, width;
		(this.enter("initializing"), this.trigger("initialize"), this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl), this.settings.autoWidth && !this.is("pre-loading")) && (imgs = this.$element.find("img"), nestedSelector = this.settings.nestedItemSelector ? "." + this.settings.nestedItemSelector : void 0, width = this.$element.children(nestedSelector).width(), imgs.length && width <= 0 && this.preloadAutoWidthImages(imgs));
		this.initializeStage(), this.initializeItems(), this.registerEventHandlers(), this.leave("initializing"), this.trigger("initialized")
	}, Owl.prototype.isVisible = function () {
		return !this.settings.checkVisibility || this.$element.is(":visible")
	}, Owl.prototype.setup = function () {
		var viewport = this.viewport(), overwrites = this.options.responsive, match = -1, settings = null;
		overwrites ? ($.each(overwrites, function (breakpoint) {
			breakpoint <= viewport && match < breakpoint && (match = Number(breakpoint))
		}), "function" == typeof (settings = $.extend({}, this.options, overwrites[match])).stagePadding && (settings.stagePadding = settings.stagePadding()), delete settings.responsive, settings.responsiveClass && this.$element.attr("class", this.$element.attr("class").replace(new RegExp("(" + this.options.responsiveClass + "-)\\S+\\s", "g"), "$1" + match))) : settings = $.extend({}, this.options), this.trigger("change", {
			property: {
				name: "settings",
				value: settings
			}
		}), this._breakpoint = match, this.settings = settings, this.invalidate("settings"), this.trigger("changed", {
			property: {
				name: "settings",
				value: this.settings
			}
		})
	}, Owl.prototype.optionsLogic = function () {
		this.settings.autoWidth && (this.settings.stagePadding = !1, this.settings.merge = !1)
	}, Owl.prototype.prepare = function (item) {
		var event = this.trigger("prepare", {content: item});
		return event.data || (event.data = $("<" + this.settings.itemElement + "/>").addClass(this.options.itemClass).append(item)), this.trigger("prepared", {content: event.data}), event.data
	}, Owl.prototype.update = function () {
		for (var i = 0, n = this._pipe.length, filter = $.proxy(function (p) {
			return this[p]
		}, this._invalidated), cache = {}; i < n;) (this._invalidated.all || 0 < $.grep(this._pipe[i].filter, filter).length) && this._pipe[i].run(cache), i++;
		this._invalidated = {}, !this.is("valid") && this.enter("valid")
	}, Owl.prototype.width = function (dimension) {
		switch (dimension = dimension || Owl.Width.Default) {
			case Owl.Width.Inner:
			case Owl.Width.Outer:
				return this._width;
			default:
				return this._width - 2 * this.settings.stagePadding + this.settings.margin
		}
	}, Owl.prototype.refresh = function () {
		this.enter("refreshing"), this.trigger("refresh"), this.setup(), this.optionsLogic(), this.$element.addClass(this.options.refreshClass), this.update(), this.$element.removeClass(this.options.refreshClass), this.leave("refreshing"), this.trigger("refreshed")
	}, Owl.prototype.onThrottledResize = function () {
		window.clearTimeout(this.resizeTimer), this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate)
	}, Owl.prototype.onResize = function () {
		return !!this._items.length && (this._width !== this.$element.width() && (!!this.isVisible() && (this.enter("resizing"), this.trigger("resize").isDefaultPrevented() ? (this.leave("resizing"), !1) : (this.invalidate("width"), this.refresh(), this.leave("resizing"), void this.trigger("resized")))))
	}, Owl.prototype.registerEventHandlers = function () {
		$.support.transition && this.$stage.on($.support.transition.end + ".owl.core", $.proxy(this.onTransitionEnd, this)), !1 !== this.settings.responsive && this.on(window, "resize", this._handlers.onThrottledResize), this.settings.mouseDrag && (this.$element.addClass(this.options.dragClass), this.$stage.on("mousedown.owl.core", $.proxy(this.onDragStart, this)), this.$stage.on("dragstart.owl.core selectstart.owl.core", function () {
			return !1
		})), this.settings.touchDrag && (this.$stage.on("touchstart.owl.core", $.proxy(this.onDragStart, this)), this.$stage.on("touchcancel.owl.core", $.proxy(this.onDragEnd, this)))
	}, Owl.prototype.onDragStart = function (event) {
		var stage = null;
		3 !== event.which && ($.support.transform ? stage = {
			x: (stage = this.$stage.css("transform").replace(/.*\(|\)| /g, "").split(","))[16 === stage.length ? 12 : 4],
			y: stage[16 === stage.length ? 13 : 5]
		} : (stage = this.$stage.position(), stage = {
			x: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,
			y: stage.top
		}), this.is("animating") && ($.support.transform ? this.animate(stage.x) : this.$stage.stop(), this.invalidate("position")), this.$element.toggleClass(this.options.grabClass, "mousedown" === event.type), this.speed(0), this._drag.time = (new Date).getTime(), this._drag.target = $(event.target), this._drag.stage.start = stage, this._drag.stage.current = stage, this._drag.pointer = this.pointer(event), $(document).on("mouseup.owl.core touchend.owl.core", $.proxy(this.onDragEnd, this)), $(document).one("mousemove.owl.core touchmove.owl.core", $.proxy(function (event) {
			var delta = this.difference(this._drag.pointer, this.pointer(event));
			$(document).on("mousemove.owl.core touchmove.owl.core", $.proxy(this.onDragMove, this)), Math.abs(delta.x) < Math.abs(delta.y) && this.is("valid") || (event.preventDefault(), this.enter("dragging"), this.trigger("drag"))
		}, this)))
	}, Owl.prototype.onDragMove = function (event) {
		var minimum = null, maximum = null, pull = null,
			delta = this.difference(this._drag.pointer, this.pointer(event)),
			stage = this.difference(this._drag.stage.start, delta);
		this.is("dragging") && (event.preventDefault(), this.settings.loop ? (minimum = this.coordinates(this.minimum()), maximum = this.coordinates(this.maximum() + 1) - minimum, stage.x = ((stage.x - minimum) % maximum + maximum) % maximum + minimum) : (minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum()), maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum()), pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0, stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull)), this._drag.stage.current = stage, this.animate(stage.x))
	}, Owl.prototype.onDragEnd = function (event) {
		var delta = this.difference(this._drag.pointer, this.pointer(event)), stage = this._drag.stage.current,
			direction = 0 < delta.x ^ this.settings.rtl ? "left" : "right";
		$(document).off(".owl.core"), this.$element.removeClass(this.options.grabClass), (0 !== delta.x && this.is("dragging") || !this.is("valid")) && (this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed), this.current(this.closest(stage.x, 0 !== delta.x ? direction : this._drag.direction)), this.invalidate("position"), this.update(), this._drag.direction = direction, (3 < Math.abs(delta.x) || 300 < (new Date).getTime() - this._drag.time) && this._drag.target.one("click.owl.core", function () {
			return !1
		})), this.is("dragging") && (this.leave("dragging"), this.trigger("dragged"))
	}, Owl.prototype.closest = function (coordinate, direction) {
		var position = -1, width = this.width(), coordinates = this.coordinates();
		return this.settings.freeDrag || $.each(coordinates, $.proxy(function (index, value) {
			return "left" === direction && value - 30 < coordinate && coordinate < value + 30 ? position = index : "right" === direction && value - width - 30 < coordinate && coordinate < value - width + 30 ? position = index + 1 : this.op(coordinate, "<", value) && this.op(coordinate, ">", void 0 !== coordinates[index + 1] ? coordinates[index + 1] : value - width) && (position = "left" === direction ? index + 1 : index), -1 === position
		}, this)), this.settings.loop || (this.op(coordinate, ">", coordinates[this.minimum()]) ? position = coordinate = this.minimum() : this.op(coordinate, "<", coordinates[this.maximum()]) && (position = coordinate = this.maximum())), position
	}, Owl.prototype.animate = function (coordinate) {
		var animate = 0 < this.speed();
		this.is("animating") && this.onTransitionEnd(), animate && (this.enter("animating"), this.trigger("translate")), $.support.transform3d && $.support.transition ? this.$stage.css({
			transform: "translate3d(" + coordinate + "px,0px,0px)",
			transition: this.speed() / 1e3 + "s" + (this.settings.slideTransition ? " " + this.settings.slideTransition : "")
		}) : animate ? this.$stage.animate({left: coordinate + "px"}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this)) : this.$stage.css({left: coordinate + "px"})
	}, Owl.prototype.is = function (state) {
		return this._states.current[state] && 0 < this._states.current[state]
	}, Owl.prototype.current = function (position) {
		if (void 0 === position) return this._current;
		if (0 !== this._items.length) {
			if (position = this.normalize(position), this._current !== position) {
				var event = this.trigger("change", {property: {name: "position", value: position}});
				void 0 !== event.data && (position = this.normalize(event.data)), this._current = position, this.invalidate("position"), this.trigger("changed", {
					property: {
						name: "position",
						value: this._current
					}
				})
			}
			return this._current
		}
	}, Owl.prototype.invalidate = function (part) {
		return "string" === $.type(part) && (this._invalidated[part] = !0, this.is("valid") && this.leave("valid")), $.map(this._invalidated, function (v, i) {
			return i
		})
	}, Owl.prototype.reset = function (position) {
		void 0 !== (position = this.normalize(position)) && (this._speed = 0, this._current = position, this.suppress(["translate", "translated"]), this.animate(this.coordinates(position)), this.release(["translate", "translated"]))
	}, Owl.prototype.normalize = function (position, relative) {
		var n = this._items.length, m = relative ? 0 : this._clones.length;
		return !this.isNumeric(position) || n < 1 ? position = void 0 : (position < 0 || n + m <= position) && (position = ((position - m / 2) % n + n) % n + m / 2), position
	}, Owl.prototype.relative = function (position) {
		return position -= this._clones.length / 2, this.normalize(position, !0)
	}, Owl.prototype.maximum = function (relative) {
		var iterator, reciprocalItemsWidth, elementWidth, settings = this.settings, maximum = this._coordinates.length;
		if (settings.loop) maximum = this._clones.length / 2 + this._items.length - 1; else if (settings.autoWidth || settings.merge) {
			if (iterator = this._items.length) for (reciprocalItemsWidth = this._items[--iterator].width(), elementWidth = this.$element.width(); iterator-- && !(elementWidth < (reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin));) ;
			maximum = iterator + 1
		} else maximum = settings.center ? this._items.length - 1 : this._items.length - settings.items;
		return relative && (maximum -= this._clones.length / 2), Math.max(maximum, 0)
	}, Owl.prototype.minimum = function (relative) {
		return relative ? 0 : this._clones.length / 2
	}, Owl.prototype.items = function (position) {
		return void 0 === position ? this._items.slice() : (position = this.normalize(position, !0), this._items[position])
	}, Owl.prototype.mergers = function (position) {
		return void 0 === position ? this._mergers.slice() : (position = this.normalize(position, !0), this._mergers[position])
	}, Owl.prototype.clones = function (position) {
		var odd = this._clones.length / 2, even = odd + this._items.length, map = function (index) {
			return index % 2 == 0 ? even + index / 2 : odd - (index + 1) / 2
		};
		return void 0 === position ? $.map(this._clones, function (v, i) {
			return map(i)
		}) : $.map(this._clones, function (v, i) {
			return v === position ? map(i) : null
		})
	}, Owl.prototype.speed = function (speed) {
		return void 0 !== speed && (this._speed = speed), this._speed
	}, Owl.prototype.coordinates = function (position) {
		var coordinate, multiplier = 1, newPosition = position - 1;
		return void 0 === position ? $.map(this._coordinates, $.proxy(function (coordinate, index) {
			return this.coordinates(index)
		}, this)) : (this.settings.center ? (this.settings.rtl && (multiplier = -1, newPosition = position + 1), coordinate = this._coordinates[position], coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier) : coordinate = this._coordinates[newPosition] || 0, coordinate = Math.ceil(coordinate))
	}, Owl.prototype.duration = function (from, to, factor) {
		return 0 === factor ? 0 : Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs(factor || this.settings.smartSpeed)
	}, Owl.prototype.to = function (position, speed) {
		var current = this.current(), revert = null, distance = position - this.relative(current),
			direction = (0 < distance) - (distance < 0), items = this._items.length, minimum = this.minimum(),
			maximum = this.maximum();
		this.settings.loop ? (!this.settings.rewind && Math.abs(distance) > items / 2 && (distance += -1 * direction * items), (revert = (((position = current + distance) - minimum) % items + items) % items + minimum) !== position && revert - distance <= maximum && 0 < revert - distance && (current = revert - distance, position = revert, this.reset(current))) : position = this.settings.rewind ? (position % (maximum += 1) + maximum) % maximum : Math.max(minimum, Math.min(maximum, position)), this.speed(this.duration(current, position, speed)), this.current(position), this.isVisible() && this.update()
	}, Owl.prototype.next = function (speed) {
		speed = speed || !1, this.to(this.relative(this.current()) + 1, speed)
	}, Owl.prototype.prev = function (speed) {
		speed = speed || !1, this.to(this.relative(this.current()) - 1, speed)
	}, Owl.prototype.onTransitionEnd = function (event) {
		if (void 0 !== event && (event.stopPropagation(), (event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0))) return !1;
		this.leave("animating"), this.trigger("translated")
	}, Owl.prototype.viewport = function () {
		var width;
		return this.options.responsiveBaseElement !== window ? width = $(this.options.responsiveBaseElement).width() : window.innerWidth ? width = window.innerWidth : document.documentElement && document.documentElement.clientWidth ? width = document.documentElement.clientWidth : console.warn("Can not detect viewport width."), width
	}, Owl.prototype.replace = function (content) {
		this.$stage.empty(), this._items = [], content && (content = content instanceof jQuery ? content : $(content)), this.settings.nestedItemSelector && (content = content.find("." + this.settings.nestedItemSelector)), content.filter(function () {
			return 1 === this.nodeType
		}).each($.proxy(function (index, item) {
			item = this.prepare(item), this.$stage.append(item), this._items.push(item), this._mergers.push(1 * item.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)
		}, this)), this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate("items")
	}, Owl.prototype.add = function (content, position) {
		var current = this.relative(this._current);
		position = void 0 === position ? this._items.length : this.normalize(position, !0), content = content instanceof jQuery ? content : $(content), this.trigger("add", {
			content: content,
			position: position
		}), content = this.prepare(content), 0 === this._items.length || position === this._items.length ? (0 === this._items.length && this.$stage.append(content), 0 !== this._items.length && this._items[position - 1].after(content), this._items.push(content), this._mergers.push(1 * content.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)) : (this._items[position].before(content), this._items.splice(position, 0, content), this._mergers.splice(position, 0, 1 * content.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)), this._items[current] && this.reset(this._items[current].index()), this.invalidate("items"), this.trigger("added", {
			content: content,
			position: position
		})
	}, Owl.prototype.remove = function (position) {
		void 0 !== (position = this.normalize(position, !0)) && (this.trigger("remove", {
			content: this._items[position],
			position: position
		}), this._items[position].remove(), this._items.splice(position, 1), this._mergers.splice(position, 1), this.invalidate("items"), this.trigger("removed", {
			content: null,
			position: position
		}))
	}, Owl.prototype.preloadAutoWidthImages = function (images) {
		images.each($.proxy(function (i, element) {
			this.enter("pre-loading"), element = $(element), $(new Image).one("load", $.proxy(function (e) {
				element.attr("src", e.target.src), element.css("opacity", 1), this.leave("pre-loading"), !this.is("pre-loading") && !this.is("initializing") && this.refresh()
			}, this)).attr("src", element.attr("src") || element.attr("data-src") || element.attr("data-src-retina"))
		}, this))
	}, Owl.prototype.destroy = function () {
		for (var i in this.$element.off(".owl.core"), this.$stage.off(".owl.core"), $(document).off(".owl.core"), !1 !== this.settings.responsive && (window.clearTimeout(this.resizeTimer), this.off(window, "resize", this._handlers.onThrottledResize)), this._plugins) this._plugins[i].destroy();
		this.$stage.children(".cloned").remove(), this.$stage.unwrap(), this.$stage.children().contents().unwrap(), this.$stage.children().unwrap(), this.$stage.remove(), this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class", this.$element.attr("class").replace(new RegExp(this.options.responsiveClass + "-\\S+\\s", "g"), "")).removeData("owl.carousel")
	}, Owl.prototype.op = function (a, o, b) {
		var rtl = this.settings.rtl;
		switch (o) {
			case"<":
				return rtl ? b < a : a < b;
			case">":
				return rtl ? a < b : b < a;
			case">=":
				return rtl ? a <= b : b <= a;
			case"<=":
				return rtl ? b <= a : a <= b
		}
	}, Owl.prototype.on = function (element, event, listener, capture) {
		element.addEventListener ? element.addEventListener(event, listener, capture) : element.attachEvent && element.attachEvent("on" + event, listener)
	}, Owl.prototype.off = function (element, event, listener, capture) {
		element.removeEventListener ? element.removeEventListener(event, listener, capture) : element.detachEvent && element.detachEvent("on" + event, listener)
	}, Owl.prototype.trigger = function (name, data, namespace, state, enter) {
		var status = {item: {count: this._items.length, index: this.current()}},
			handler = $.camelCase($.grep(["on", name, namespace], function (v) {
				return v
			}).join("-").toLowerCase()),
			event = $.Event([name, "owl", namespace || "carousel"].join(".").toLowerCase(), $.extend({relatedTarget: this}, status, data));
		return this._supress[name] || ($.each(this._plugins, function (name, plugin) {
			plugin.onTrigger && plugin.onTrigger(event)
		}), this.register({
			type: Owl.Type.Event,
			name: name
		}), this.$element.trigger(event), this.settings && "function" == typeof this.settings[handler] && this.settings[handler].call(this, event)), event
	}, Owl.prototype.enter = function (name) {
		$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
			void 0 === this._states.current[name] && (this._states.current[name] = 0), this._states.current[name]++
		}, this))
	}, Owl.prototype.leave = function (name) {
		$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
			this._states.current[name]--
		}, this))
	}, Owl.prototype.register = function (object) {
		if (object.type === Owl.Type.Event) {
			if ($.event.special[object.name] || ($.event.special[object.name] = {}), !$.event.special[object.name].owl) {
				var _default = $.event.special[object.name]._default;
				$.event.special[object.name]._default = function (e) {
					return !_default || !_default.apply || e.namespace && -1 !== e.namespace.indexOf("owl") ? e.namespace && -1 < e.namespace.indexOf("owl") : _default.apply(this, arguments)
				}, $.event.special[object.name].owl = !0
			}
		} else object.type === Owl.Type.State && (this._states.tags[object.name] ? this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags) : this._states.tags[object.name] = object.tags, this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {
			return $.inArray(tag, this._states.tags[object.name]) === i
		}, this)))
	}, Owl.prototype.suppress = function (events) {
		$.each(events, $.proxy(function (index, event) {
			this._supress[event] = !0
		}, this))
	}, Owl.prototype.release = function (events) {
		$.each(events, $.proxy(function (index, event) {
			delete this._supress[event]
		}, this))
	}, Owl.prototype.pointer = function (event) {
		var result = {x: null, y: null};
		return (event = (event = event.originalEvent || event || window.event).touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event).pageX ? (result.x = event.pageX, result.y = event.pageY) : (result.x = event.clientX, result.y = event.clientY), result
	}, Owl.prototype.isNumeric = function (number) {
		return !isNaN(parseFloat(number))
	}, Owl.prototype.difference = function (first, second) {
		return {x: first.x - second.x, y: first.y - second.y}
	}, $.fn.owlCarousel = function (option) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.each(function () {
			var $this = $(this), data = $this.data("owl.carousel");
			data || (data = new Owl(this, "object" == (void 0 === option ? "undefined" : _typeof2(option)) && option), $this.data("owl.carousel", data), $.each(["next", "prev", "to", "destroy", "refresh", "replace", "add", "remove"], function (i, event) {
				data.register({
					type: Owl.Type.Event,
					name: event
				}), data.$element.on(event + ".owl.carousel.core", $.proxy(function (e) {
					e.namespace && e.relatedTarget !== this && (this.suppress([event]), data[event].apply(this, [].slice.call(arguments, 1)), this.release([event]))
				}, data))
			})), "string" == typeof option && "_" !== option.charAt(0) && data[option].apply(data, args)
		})
	}, $.fn.owlCarousel.Constructor = Owl
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var AutoRefresh = function AutoRefresh(carousel) {
		this._core = carousel, this._interval = null, this._visible = null, this._handlers = {
			"initialized.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.autoRefresh && this.watch()
			}, this)
		}, this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options), this._core.$element.on(this._handlers)
	};
	AutoRefresh.Defaults = {autoRefresh: !0, autoRefreshInterval: 500}, AutoRefresh.prototype.watch = function () {
		this._interval || (this._visible = this._core.isVisible(), this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval))
	}, AutoRefresh.prototype.refresh = function () {
		this._core.isVisible() !== this._visible && (this._visible = !this._visible, this._core.$element.toggleClass("owl-hidden", !this._visible), this._visible && this._core.invalidate("width") && this._core.refresh())
	}, AutoRefresh.prototype.destroy = function () {
		var handler, property;
		for (handler in window.clearInterval(this._interval), this._handlers) this._core.$element.off(handler, this._handlers[handler]);
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var Lazy = function Lazy(carousel) {
		this._core = carousel, this._loaded = [], this._handlers = {
			"initialized.owl.carousel change.owl.carousel resized.owl.carousel": $.proxy(function (e) {
				if (e.namespace && this._core.settings && this._core.settings.lazyLoad && (e.property && "position" == e.property.name || "initialized" == e.type)) {
					var settings = this._core.settings,
						n = settings.center && Math.ceil(settings.items / 2) || settings.items,
						i = settings.center && -1 * n || 0,
						position = (e.property && void 0 !== e.property.value ? e.property.value : this._core.current()) + i,
						clones = this._core.clones().length, load = $.proxy(function (i, v) {
							this.load(v)
						}, this);
					for (0 < settings.lazyLoadEager && (n += settings.lazyLoadEager, settings.loop && (position -= settings.lazyLoadEager, n++)); i++ < n;) this.load(clones / 2 + this._core.relative(position)), clones && $.each(this._core.clones(this._core.relative(position)), load), position++
				}
			}, this)
		}, this._core.options = $.extend({}, Lazy.Defaults, this._core.options), this._core.$element.on(this._handlers)
	};
	Lazy.Defaults = {lazyLoad: !1, lazyLoadEager: 0}, Lazy.prototype.load = function (position) {
		var $item = this._core.$stage.children().eq(position), $elements = $item && $item.find(".owl-lazy");
		!$elements || -1 < $.inArray($item.get(0), this._loaded) || ($elements.each($.proxy(function (index, element) {
			var image, $element = $(element),
				url = 1 < window.devicePixelRatio && $element.attr("data-src-retina") || $element.attr("data-src") || $element.attr("data-srcset");
			this._core.trigger("load", {
				element: $element,
				url: url
			}, "lazy"), $element.is("img") ? $element.one("load.owl.lazy", $.proxy(function () {
				$element.css("opacity", 1), this._core.trigger("loaded", {element: $element, url: url}, "lazy")
			}, this)).attr("src", url) : $element.is("source") ? $element.one("load.owl.lazy", $.proxy(function () {
				this._core.trigger("loaded", {element: $element, url: url}, "lazy")
			}, this)).attr("srcset", url) : ((image = new Image).onload = $.proxy(function () {
				$element.css({
					"background-image": 'url("' + url + '")',
					opacity: "1"
				}), this._core.trigger("loaded", {element: $element, url: url}, "lazy")
			}, this), image.src = url)
		}, this)), this._loaded.push($item.get(0)))
	}, Lazy.prototype.destroy = function () {
		var handler, property;
		for (handler in this.handlers) this._core.$element.off(handler, this.handlers[handler]);
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var AutoHeight = function AutoHeight(carousel) {
		this._core = carousel, this._previousHeight = null, this._handlers = {
			"initialized.owl.carousel refreshed.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.autoHeight && this.update()
			}, this), "changed.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.autoHeight && "position" === e.property.name && this.update()
			}, this), "loaded.owl.lazy": $.proxy(function (e) {
				e.namespace && this._core.settings.autoHeight && e.element.closest("." + this._core.settings.itemClass).index() === this._core.current() && this.update()
			}, this)
		}, this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options), this._core.$element.on(this._handlers), this._intervalId = null;
		var refThis = this;
		$(window).on("load", function () {
			refThis._core.settings.autoHeight && refThis.update()
		}), $(window).resize(function () {
			refThis._core.settings.autoHeight && (null != refThis._intervalId && clearTimeout(refThis._intervalId), refThis._intervalId = setTimeout(function () {
				refThis.update()
			}, 250))
		})
	};
	AutoHeight.Defaults = {autoHeight: !1, autoHeightClass: "owl-height"}, AutoHeight.prototype.update = function () {
		var start = this._core._current, end = start + this._core.settings.items,
			lazyLoadEnabled = this._core.settings.lazyLoad,
			visible = this._core.$stage.children().toArray().slice(start, end), heights = [], maxheight = 0;
		$.each(visible, function (index, item) {
			heights.push($(item).height())
		}), (maxheight = Math.max.apply(null, heights)) <= 1 && lazyLoadEnabled && this._previousHeight && (maxheight = this._previousHeight), this._previousHeight = maxheight, this._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass)
	}, AutoHeight.prototype.destroy = function () {
		var handler, property;
		for (handler in this._handlers) this._core.$element.off(handler, this._handlers[handler]);
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var Video = function Video(carousel) {
		this._core = carousel, this._videos = {}, this._playing = null, this._handlers = {
			"initialized.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.register({type: "state", name: "playing", tags: ["interacting"]})
			}, this), "resize.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.video && this.isInFullScreen() && e.preventDefault()
			}, this), "refreshed.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.is("resizing") && this._core.$stage.find(".cloned .owl-video-frame").remove()
			}, this), "changed.owl.carousel": $.proxy(function (e) {
				e.namespace && "position" === e.property.name && this._playing && this.stop()
			}, this), "prepared.owl.carousel": $.proxy(function (e) {
				if (e.namespace) {
					var $element = $(e.content).find(".owl-video");
					$element.length && ($element.css("display", "none"), this.fetch($element, $(e.content)))
				}
			}, this)
		}, this._core.options = $.extend({}, Video.Defaults, this._core.options), this._core.$element.on(this._handlers), this._core.$element.on("click.owl.video", ".owl-video-play-icon", $.proxy(function (e) {
			this.play(e)
		}, this))
	};
	Video.Defaults = {video: !1, videoHeight: !1, videoWidth: !1}, Video.prototype.fetch = function (target, item) {
		var type = target.attr("data-vimeo-id") ? "vimeo" : target.attr("data-vzaar-id") ? "vzaar" : "youtube",
			id = target.attr("data-vimeo-id") || target.attr("data-youtube-id") || target.attr("data-vzaar-id"),
			width = target.attr("data-width") || this._core.settings.videoWidth,
			height = target.attr("data-height") || this._core.settings.videoHeight, url = target.attr("href");
		if (!url) throw new Error("Missing video URL.");
		if (-1 < (id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/))[3].indexOf("youtu")) type = "youtube"; else if (-1 < id[3].indexOf("vimeo")) type = "vimeo"; else {
			if (!(-1 < id[3].indexOf("vzaar"))) throw new Error("Video URL not supported.");
			type = "vzaar"
		}
		id = id[6], this._videos[url] = {
			type: type,
			id: id,
			width: width,
			height: height
		}, item.attr("data-video", url), this.thumbnail(target, this._videos[url])
	}, Video.prototype.thumbnail = function (target, video) {
		var tnLink, path,
			dimensions = video.width && video.height ? "width:" + video.width + "px;height:" + video.height + "px;" : "",
			customTn = target.find("img"), srcType = "src", lazyClass = "", settings = this._core.settings,
			create = function (path) {
				'<div class="owl-video-play-icon"></div>', tnLink = settings.lazyLoad ? $("<div/>", {
					class: "owl-video-tn " + lazyClass,
					srcType: path
				}) : $("<div/>", {
					class: "owl-video-tn",
					style: "opacity:1;background-image:url(" + path + ")"
				}), target.after(tnLink), target.after('<div class="owl-video-play-icon"></div>')
			};
		if (target.wrap($("<div/>", {
			class: "owl-video-wrapper",
			style: dimensions
		})), this._core.settings.lazyLoad && (srcType = "data-src", lazyClass = "owl-lazy"), customTn.length) return create(customTn.attr(srcType)), customTn.remove(), !1;
		"youtube" === video.type ? (path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg", create(path)) : "vimeo" === video.type ? $.ajax({
			type: "GET",
			url: "//vimeo.com/api/v2/video/" + video.id + ".json",
			jsonp: "callback",
			dataType: "jsonp",
			success: function (data) {
				path = data[0].thumbnail_large, create(path)
			}
		}) : "vzaar" === video.type && $.ajax({
			type: "GET",
			url: "//vzaar.com/api/videos/" + video.id + ".json",
			jsonp: "callback",
			dataType: "jsonp",
			success: function (data) {
				path = data.framegrab_url, create(path)
			}
		})
	}, Video.prototype.stop = function () {
		this._core.trigger("stop", null, "video"), this._playing.find(".owl-video-frame").remove(), this._playing.removeClass("owl-video-playing"), this._playing = null, this._core.leave("playing"), this._core.trigger("stopped", null, "video")
	}, Video.prototype.play = function (event) {
		var html, item = $(event.target).closest("." + this._core.settings.itemClass),
			video = this._videos[item.attr("data-video")], width = video.width || "100%",
			height = video.height || this._core.$stage.height();
		this._playing || (this._core.enter("playing"), this._core.trigger("play", null, "video"), item = this._core.items(this._core.relative(item.index())), this._core.reset(item.index()), (html = $('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>')).attr("height", height), html.attr("width", width), "youtube" === video.type ? html.attr("src", "//www.youtube.com/embed/" + video.id + "?autoplay=1&rel=0&v=" + video.id) : "vimeo" === video.type ? html.attr("src", "//player.vimeo.com/video/" + video.id + "?autoplay=1") : "vzaar" === video.type && html.attr("src", "//view.vzaar.com/" + video.id + "/player?autoplay=true"), $(html).wrap('<div class="owl-video-frame" />').insertAfter(item.find(".owl-video")), this._playing = item.addClass("owl-video-playing"))
	}, Video.prototype.isInFullScreen = function () {
		var element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
		return element && $(element).parent().hasClass("owl-video-frame")
	}, Video.prototype.destroy = function () {
		var handler, property;
		for (handler in this._core.$element.off("click.owl.video"), this._handlers) this._core.$element.off(handler, this._handlers[handler]);
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, $.fn.owlCarousel.Constructor.Plugins.Video = Video
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var Animate = function Animate(scope) {
		this.core = scope, this.core.options = $.extend({}, Animate.Defaults, this.core.options), this.swapping = !0, this.previous = void 0, this.next = void 0, this.handlers = {
			"change.owl.carousel": $.proxy(function (e) {
				e.namespace && "position" == e.property.name && (this.previous = this.core.current(), this.next = e.property.value)
			}, this), "drag.owl.carousel dragged.owl.carousel translated.owl.carousel": $.proxy(function (e) {
				e.namespace && (this.swapping = "translated" == e.type)
			}, this), "translate.owl.carousel": $.proxy(function (e) {
				e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn) && this.swap()
			}, this)
		}, this.core.$element.on(this.handlers)
	};
	Animate.Defaults = {animateOut: !1, animateIn: !1}, Animate.prototype.swap = function () {
		if (1 === this.core.settings.items && $.support.animation && $.support.transition) {
			this.core.speed(0);
			var left, clear = $.proxy(this.clear, this), previous = this.core.$stage.children().eq(this.previous),
				next = this.core.$stage.children().eq(this.next), incoming = this.core.settings.animateIn,
				outgoing = this.core.settings.animateOut;
			this.core.current() !== this.previous && (outgoing && (left = this.core.coordinates(this.previous) - this.core.coordinates(this.next), previous.one($.support.animation.end, clear).css({left: left + "px"}).addClass("animated owl-animated-out").addClass(outgoing)), incoming && next.one($.support.animation.end, clear).addClass("animated owl-animated-in").addClass(incoming))
		}
	}, Animate.prototype.clear = function (e) {
		$(e.target).css({left: ""}).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut), this.core.onTransitionEnd()
	}, Animate.prototype.destroy = function () {
		var handler, property;
		for (handler in this.handlers) this.core.$element.off(handler, this.handlers[handler]);
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, $.fn.owlCarousel.Constructor.Plugins.Animate = Animate
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var Autoplay = function Autoplay(carousel) {
		this._core = carousel, this._call = null, this._time = 0, this._timeout = 0, this._paused = !0, this._handlers = {
			"changed.owl.carousel": $.proxy(function (e) {
				e.namespace && "settings" === e.property.name ? this._core.settings.autoplay ? this.play() : this.stop() : e.namespace && "position" === e.property.name && this._paused && (this._time = 0)
			}, this), "initialized.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.autoplay && this.play()
			}, this), "play.owl.autoplay": $.proxy(function (e, t, s) {
				e.namespace && this.play(t, s)
			}, this), "stop.owl.autoplay": $.proxy(function (e) {
				e.namespace && this.stop()
			}, this), "mouseover.owl.autoplay": $.proxy(function () {
				this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause()
			}, this), "mouseleave.owl.autoplay": $.proxy(function () {
				this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.play()
			}, this), "touchstart.owl.core": $.proxy(function () {
				this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause()
			}, this), "touchend.owl.core": $.proxy(function () {
				this._core.settings.autoplayHoverPause && this.play()
			}, this)
		}, this._core.$element.on(this._handlers), this._core.options = $.extend({}, Autoplay.Defaults, this._core.options)
	};
	Autoplay.Defaults = {
		autoplay: !1,
		autoplayTimeout: 5e3,
		autoplayHoverPause: !1,
		autoplaySpeed: !1
	}, Autoplay.prototype._next = function (speed) {
		this._call = window.setTimeout($.proxy(this._next, this, speed), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()), this._core.is("interacting") || document.hidden || this._core.next(speed || this._core.settings.autoplaySpeed)
	}, Autoplay.prototype.read = function () {
		return (new Date).getTime() - this._time
	}, Autoplay.prototype.play = function (timeout, speed) {
		var elapsed;
		this._core.is("rotating") || this._core.enter("rotating"), timeout = timeout || this._core.settings.autoplayTimeout, elapsed = Math.min(this._time % (this._timeout || timeout), timeout), this._paused ? (this._time = this.read(), this._paused = !1) : window.clearTimeout(this._call), this._time += this.read() % timeout - elapsed, this._timeout = timeout, this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed)
	}, Autoplay.prototype.stop = function () {
		this._core.is("rotating") && (this._time = 0, this._paused = !0, window.clearTimeout(this._call), this._core.leave("rotating"))
	}, Autoplay.prototype.pause = function () {
		this._core.is("rotating") && !this._paused && (this._time = this.read(), this._paused = !0, window.clearTimeout(this._call))
	}, Autoplay.prototype.destroy = function () {
		var handler, property;
		for (handler in this.stop(), this._handlers) this._core.$element.off(handler, this._handlers[handler]);
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var Navigation = function Navigation(carousel) {
		this._core = carousel, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = {
			next: this._core.next,
			prev: this._core.prev,
			to: this._core.to
		}, this._handlers = {
			"prepared.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.dotsData && this._templates.push('<div class="' + this._core.settings.dotClass + '">' + $(e.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot") + "</div>")
			}, this), "added.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.dotsData && this._templates.splice(e.position, 0, this._templates.pop())
			}, this), "remove.owl.carousel": $.proxy(function (e) {
				e.namespace && this._core.settings.dotsData && this._templates.splice(e.position, 1)
			}, this), "changed.owl.carousel": $.proxy(function (e) {
				e.namespace && "position" == e.property.name && this.draw()
			}, this), "initialized.owl.carousel": $.proxy(function (e) {
				e.namespace && !this._initialized && (this._core.trigger("initialize", null, "navigation"), this.initialize(), this.update(), this.draw(), this._initialized = !0, this._core.trigger("initialized", null, "navigation"))
			}, this), "refreshed.owl.carousel": $.proxy(function (e) {
				e.namespace && this._initialized && (this._core.trigger("refresh", null, "navigation"), this.update(), this.draw(), this._core.trigger("refreshed", null, "navigation"))
			}, this)
		}, this._core.options = $.extend({}, Navigation.Defaults, this._core.options), this.$element.on(this._handlers)
	};
	Navigation.Defaults = {
		nav: !1,
		navText: ['<span aria-label="Previous">&#x2039;</span>', '<span aria-label="Next">&#x203a;</span>'],
		navSpeed: !1,
		navElement: 'button type="button" role="presentation"',
		navContainer: !1,
		navContainerClass: "owl-nav",
		navClass: ["owl-prev", "owl-next"],
		slideBy: 1,
		dotClass: "owl-dot",
		dotsClass: "owl-dots",
		dots: !0,
		dotsEach: !1,
		dotsData: !1,
		dotsSpeed: !1,
		dotsContainer: !1
	}, Navigation.prototype.initialize = function () {
		var override, settings = this._core.settings;
		for (override in this._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $("<div>").addClass(settings.navContainerClass).appendTo(this.$element)).addClass("disabled"), this._controls.$previous = $("<" + settings.navElement + ">").addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on("click", $.proxy(function (e) {
			this.prev(settings.navSpeed)
		}, this)), this._controls.$next = $("<" + settings.navElement + ">").addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on("click", $.proxy(function (e) {
			this.next(settings.navSpeed)
		}, this)), settings.dotsData || (this._templates = [$('<button role="button">').addClass(settings.dotClass).append($("<span>")).prop("outerHTML")]), this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $("<div>").addClass(settings.dotsClass).appendTo(this.$element)).addClass("disabled"), this._controls.$absolute.on("click", "button", $.proxy(function (e) {
			var index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();
			e.preventDefault(), this.to(index, settings.dotsSpeed)
		}, this)), this._overrides) this._core[override] = $.proxy(this[override], this)
	}, Navigation.prototype.destroy = function () {
		var handler, control, property, override, settings;
		for (handler in settings = this._core.settings, this._handlers) this.$element.off(handler, this._handlers[handler]);
		for (control in this._controls) "$relative" === control && settings.navContainer ? this._controls[control].html("") : this._controls[control].remove();
		for (override in this.overides) this._core[override] = this._overrides[override];
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, Navigation.prototype.update = function () {
		var i, j, lower = this._core.clones().length / 2, upper = lower + this._core.items().length,
			maximum = this._core.maximum(!0), settings = this._core.settings,
			size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;
		if ("page" !== settings.slideBy && (settings.slideBy = Math.min(settings.slideBy, settings.items)), settings.dots || "page" == settings.slideBy) for (this._pages = [], i = lower, j = 0; i < upper; i++) {
			if (size <= j || 0 === j) {
				if (this._pages.push({
					start: Math.min(maximum, i - lower),
					end: i - lower + size - 1
				}), Math.min(maximum, i - lower) === maximum) break;
				j = 0, 0
			}
			j += this._core.mergers(this._core.relative(i))
		}
	}, Navigation.prototype.draw = function () {
		var difference, settings = this._core.settings, disabled = this._core.items().length <= settings.items,
			index = this._core.relative(this._core.current()), loop = settings.loop || settings.rewind;
		this._controls.$relative.toggleClass("disabled", !settings.nav || disabled), settings.nav && (this._controls.$previous.toggleClass("disabled", !loop && index <= this._core.minimum(!0)), this._controls.$next.toggleClass("disabled", !loop && index >= this._core.maximum(!0))), this._controls.$absolute.toggleClass("disabled", !settings.dots || disabled), settings.dots && (difference = this._pages.length - this._controls.$absolute.children().length, settings.dotsData && 0 !== difference ? this._controls.$absolute.html(this._templates.join("")) : 0 < difference ? this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0])) : difference < 0 && this._controls.$absolute.children().slice(difference).remove(), this._controls.$absolute.find(".active").removeClass("active"), this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass("active"))
	}, Navigation.prototype.onTrigger = function (event) {
		var settings = this._core.settings;
		event.page = {
			index: $.inArray(this.current(), this._pages),
			count: this._pages.length,
			size: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)
		}
	}, Navigation.prototype.current = function () {
		var current = this._core.relative(this._core.current());
		return $.grep(this._pages, $.proxy(function (page, index) {
			return page.start <= current && page.end >= current
		}, this)).pop()
	}, Navigation.prototype.getPosition = function (successor) {
		var position, length, settings = this._core.settings;
		return "page" == settings.slideBy ? (position = $.inArray(this.current(), this._pages), length = this._pages.length, successor ? ++position : --position, position = this._pages[(position % length + length) % length].start) : (position = this._core.relative(this._core.current()), length = this._core.items().length, successor ? position += settings.slideBy : position -= settings.slideBy), position
	}, Navigation.prototype.next = function (speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(!0), speed)
	}, Navigation.prototype.prev = function (speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(!1), speed)
	}, Navigation.prototype.to = function (position, speed, standard) {
		var length;
		!standard && this._pages.length ? (length = this._pages.length, $.proxy(this._overrides.to, this._core)(this._pages[(position % length + length) % length].start, speed)) : $.proxy(this._overrides.to, this._core)(position, speed)
	}, $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	var Hash = function Hash(carousel) {
		this._core = carousel, this._hashes = {}, this.$element = this._core.$element, this._handlers = {
			"initialized.owl.carousel": $.proxy(function (e) {
				e.namespace && "URLHash" === this._core.settings.startPosition && $(window).trigger("hashchange.owl.navigation")
			}, this), "prepared.owl.carousel": $.proxy(function (e) {
				if (e.namespace) {
					var hash = $(e.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash");
					if (!hash) return;
					this._hashes[hash] = e.content
				}
			}, this), "changed.owl.carousel": $.proxy(function (e) {
				if (e.namespace && "position" === e.property.name) {
					var current = this._core.items(this._core.relative(this._core.current())),
						hash = $.map(this._hashes, function (item, hash) {
							return item === current ? hash : null
						}).join();
					if (!hash || window.location.hash.slice(1) === hash) return;
					window.location.hash = hash
				}
			}, this)
		}, this._core.options = $.extend({}, Hash.Defaults, this._core.options), this.$element.on(this._handlers), $(window).on("hashchange.owl.navigation", $.proxy(function (e) {
			var hash = window.location.hash.substring(1), items = this._core.$stage.children(),
				position = this._hashes[hash] && items.index(this._hashes[hash]);
			void 0 !== position && position !== this._core.current() && this._core.to(this._core.relative(position), !1, !0)
		}, this))
	};
	Hash.Defaults = {URLhashListener: !1}, Hash.prototype.destroy = function () {
		var handler, property;
		for (handler in $(window).off("hashchange.owl.navigation"), this._handlers) this._core.$element.off(handler, this._handlers[handler]);
		for (property in Object.getOwnPropertyNames(this)) "function" != typeof this[property] && (this[property] = null)
	}, $.fn.owlCarousel.Constructor.Plugins.Hash = Hash
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
	function test(property, prefixed) {
		var result = !1, upper = property.charAt(0).toUpperCase() + property.slice(1);
		return $.each((property + " " + prefixes.join(upper + " ") + upper).split(" "), function (i, property) {
			if (style[property] !== undefined) return result = !prefixed || property, !1
		}), result
	}

	function prefixed(property) {
		return test(property, !0)
	}

	var style = $("<support>").get(0).style, prefixes = "Webkit Moz O ms".split(" "), events = {
		transition: {
			end: {
				WebkitTransition: "webkitTransitionEnd",
				MozTransition: "transitionend",
				OTransition: "oTransitionEnd",
				transition: "transitionend"
			}
		},
		animation: {
			end: {
				WebkitAnimation: "webkitAnimationEnd",
				MozAnimation: "animationend",
				OAnimation: "oAnimationEnd",
				animation: "animationend"
			}
		}
	}, tests_csstransforms = function () {
		return !!test("transform")
	}, tests_csstransforms3d = function () {
		return !!test("perspective")
	}, tests_cssanimations = function () {
		return !!test("animation")
	};
	(function () {
		return !!test("transition")
	})() && ($.support.transition = new String(prefixed("transition")), $.support.transition.end = events.transition.end[$.support.transition]), tests_cssanimations() && ($.support.animation = new String(prefixed("animation")), $.support.animation.end = events.animation.end[$.support.animation]), tests_csstransforms() && ($.support.transform = new String(prefixed("transform")), $.support.transform3d = tests_csstransforms3d())
}(window.Zepto || window.jQuery, window, document), function (window) {
	function convertStyle(obj) {
		var style = "";
		for (var a in obj) obj.hasOwnProperty(a) && (style += a + ":" + obj[a] + ";");
		return style
	}

	function showEffect(e) {
		var element = function (e) {
			if (!1 === TouchHandler.allowEvent(e)) return null;
			for (var element = null, target = e.target || e.srcElement; null !== target.parentElement;) {
				if (!(target instanceof SVGElement || -1 === target.className.indexOf("waves-effect"))) {
					element = target;
					break
				}
				if (target.classList.contains("waves-effect")) {
					element = target;
					break
				}
				target = target.parentElement
			}
			return element
		}(e);
		null !== element && (Effect.show(e, element), "ontouchstart" in window && (element.addEventListener("touchend", Effect.hide, !1), element.addEventListener("touchcancel", Effect.hide, !1)), element.addEventListener("mouseup", Effect.hide, !1), element.addEventListener("mouseleave", Effect.hide, !1))
	}

	var Waves = Waves || {}, $$ = document.querySelectorAll.bind(document), Effect = {
		duration: 750, show: function (e, element) {
			if (2 === e.button) return !1;
			var el = element || this, ripple = document.createElement("div");
			ripple.className = "waves-ripple", el.appendChild(ripple);
			var elem, docElem, win, box, doc, pos = (box = {
					top: 0,
					left: 0
				}, doc = (elem = el) && elem.ownerDocument, docElem = doc.documentElement, "undefined" !== _typeof2(elem.getBoundingClientRect) && (box = elem.getBoundingClientRect()), win = function (elem) {
					return null !== (obj = elem) && obj === obj.window ? elem : 9 === elem.nodeType && elem.defaultView;
					var obj
				}(doc), {
					top: box.top + win.pageYOffset - docElem.clientTop,
					left: box.left + win.pageXOffset - docElem.clientLeft
				}), relativeY = e.pageY - pos.top, relativeX = e.pageX - pos.left,
				scale = "scale(" + el.clientWidth / 100 * 10 + ")";
			"touches" in e && (relativeY = e.touches[0].pageY - pos.top, relativeX = e.touches[0].pageX - pos.left), ripple.setAttribute("data-hold", Date.now()), ripple.setAttribute("data-scale", scale), ripple.setAttribute("data-x", relativeX), ripple.setAttribute("data-y", relativeY);
			var rippleStyle = {top: relativeY + "px", left: relativeX + "px"};
			ripple.className = ripple.className + " waves-notransition", ripple.setAttribute("style", convertStyle(rippleStyle)), ripple.className = ripple.className.replace("waves-notransition", ""), rippleStyle["-webkit-transform"] = scale, rippleStyle["-moz-transform"] = scale, rippleStyle["-ms-transform"] = scale, rippleStyle["-o-transform"] = scale, rippleStyle.transform = scale, rippleStyle.opacity = "0.4", rippleStyle["-webkit-transition-duration"] = Effect.duration + "ms", rippleStyle["-moz-transition-duration"] = Effect.duration + "ms", rippleStyle["-o-transition-duration"] = Effect.duration + "ms", rippleStyle["transition-duration"] = Effect.duration + "ms", rippleStyle["-webkit-transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)", rippleStyle["-moz-transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)", rippleStyle["-o-transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)", rippleStyle["transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)", ripple.setAttribute("style", convertStyle(rippleStyle))
		}, hide: function (e) {
			TouchHandler.touchup(e);
			var el = this, ripple = (el.clientWidth, null), ripples = el.getElementsByClassName("waves-ripple");
			if (!(0 < ripples.length)) return !1;
			var relativeX = (ripple = ripples[ripples.length - 1]).getAttribute("data-x"),
				relativeY = ripple.getAttribute("data-y"), scale = ripple.getAttribute("data-scale"),
				delay = 350 - (Date.now() - Number(ripple.getAttribute("data-hold")));
			delay < 0 && (delay = 0), setTimeout(function () {
				var style = {
					top: relativeY + "px",
					left: relativeX + "px",
					opacity: "0",
					"-webkit-transition-duration": Effect.duration + "ms",
					"-moz-transition-duration": Effect.duration + "ms",
					"-o-transition-duration": Effect.duration + "ms",
					"transition-duration": Effect.duration + "ms",
					"-webkit-transform": scale,
					"-moz-transform": scale,
					"-ms-transform": scale,
					"-o-transform": scale,
					transform: scale
				};
				ripple.setAttribute("style", convertStyle(style)), setTimeout(function () {
					try {
						el.removeChild(ripple)
					} catch (e) {
						return !1
					}
				}, Effect.duration)
			}, delay)
		}, wrapInput: function (elements) {
			for (var a = 0; a < elements.length; a++) {
				var el = elements[a];
				if ("input" === el.tagName.toLowerCase()) {
					var parent = el.parentNode;
					if ("i" === parent.tagName.toLowerCase() && -1 !== parent.className.indexOf("waves-effect")) continue;
					var wrapper = document.createElement("i");
					wrapper.className = el.className + " waves-input-wrapper";
					var elementStyle = el.getAttribute("style");
					elementStyle || (elementStyle = ""), wrapper.setAttribute("style", elementStyle), el.className = "waves-button-input", el.removeAttribute("style"), parent.replaceChild(wrapper, el), wrapper.appendChild(el)
				}
			}
		}
	}, TouchHandler = {
		touches: 0, allowEvent: function (e) {
			var allow = !0;
			return "touchstart" === e.type ? TouchHandler.touches += 1 : "touchend" === e.type || "touchcancel" === e.type ? setTimeout(function () {
				0 < TouchHandler.touches && (TouchHandler.touches -= 1)
			}, 500) : "mousedown" === e.type && 0 < TouchHandler.touches && (allow = !1), allow
		}, touchup: function (e) {
			TouchHandler.allowEvent(e)
		}
	};
	Waves.displayEffect = function (options) {
		"duration" in (options = options || {}) && (Effect.duration = options.duration), Effect.wrapInput($$(".waves-effect")), "ontouchstart" in window && document.body.addEventListener("touchstart", showEffect, !1), document.body.addEventListener("mousedown", showEffect, !1)
	}, Waves.attach = function (element) {
		"input" === element.tagName.toLowerCase() && (Effect.wrapInput([element]), element = element.parentElement), "ontouchstart" in window && element.addEventListener("touchstart", showEffect, !1), element.addEventListener("mousedown", showEffect, !1)
	}, window.Waves = Waves, document.addEventListener("DOMContentLoaded", function () {
		Waves.displayEffect()
	}, !1)
}(window), function (root, factory) {
	if ("object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module))) module.exports = factory(require("jquery")); else if ("function" == typeof define && define.amd) define(["jquery"], factory); else {
		var a = "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) ? factory(require("jquery")) : factory(root.jQuery);
		for (var i in a) ("object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) ? exports : root)[i] = a[i]
	}
}(window, function (__WEBPACK_EXTERNAL_MODULE__5__) {
	function __webpack_require__(moduleId) {
		if (installedModules[moduleId]) return installedModules[moduleId].exports;
		var module = installedModules[moduleId] = {i: moduleId, l: !1, exports: {}};
		return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports
	}

	return modules = [function (module, exports, __webpack_require__) {
		var im = __webpack_require__(1), jQuery = __webpack_require__(5);
		im.dependencyLib === jQuery && __webpack_require__(11), module.exports = im
	}, function (module, exports, __webpack_require__) {
		__webpack_require__(2), __webpack_require__(9), __webpack_require__(10), module.exports = __webpack_require__(3)
	}, function (module, exports, __webpack_require__) {
		function ipValidator(chrs, maskset, pos, strict, opts) {
			return chrs = -1 < pos - 1 && "." !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, -1 < pos - 2 && "." !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : "0" + chrs) : "00" + chrs, new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(chrs)
		}

		var Inputmask = __webpack_require__(3);
		Inputmask.extendDefinitions({
			A: {validator: "[A-Za-zА-яЁёÀ-ÿµ]", casing: "upper"},
			"&": {validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]", casing: "upper"},
			"#": {validator: "[0-9A-Fa-f]", casing: "upper"}
		}), Inputmask.extendAliases({
			cssunit: {regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"},
			url: {regex: "(https?|ftp)//.*", autoUnmask: !1},
			ip: {
				mask: "i[i[i]].j[j[j]].k[k[k]].l[l[l]]",
				definitions: {
					i: {validator: ipValidator},
					j: {validator: ipValidator},
					k: {validator: ipValidator},
					l: {validator: ipValidator}
				},
				onUnMask: function (maskedValue, unmaskedValue, opts) {
					return maskedValue
				},
				inputmode: "numeric"
			},
			email: {
				mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
				greedy: !1,
				casing: "lower",
				onBeforePaste: function (pastedValue, opts) {
					return (pastedValue = pastedValue.toLowerCase()).replace("mailto:", "")
				},
				definitions: {
					"*": {validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ!#$%&'*+/=?^_`{|}~-]"},
					"-": {validator: "[0-9A-Za-z-]"}
				},
				onUnMask: function (maskedValue, unmaskedValue, opts) {
					return maskedValue
				},
				inputmode: "email"
			},
			mac: {mask: "##:##:##:##:##:##"},
			vin: {
				mask: "V{13}9{4}",
				definitions: {V: {validator: "[A-HJ-NPR-Za-hj-npr-z\\d]", casing: "upper"}},
				clearIncomplete: !0,
				autoUnmask: !0
			}
		}), module.exports = Inputmask
	}, function (module, exports, __webpack_require__) {
		function _typeof(obj) {
			return (_typeof = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function (obj) {
				return void 0 === obj ? "undefined" : _typeof2(obj)
			} : function (obj) {
				return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : void 0 === obj ? "undefined" : _typeof2(obj)
			})(obj)
		}

		function Inputmask(alias, options, internal) {
			if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);
			this.el = void 0, this.events = {}, this.maskset = void 0, !(this.refreshValue = !1) !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}, alias && (options.alias = alias)), this.opts = $.extend(!0, {}, this.defaults, options), this.noMasksCache = options && void 0 !== options.definitions, this.userOptions = options || {}, resolveAlias(this.opts.alias, options, this.opts), this.isRTL = this.opts.numericInput)
		}

		function resolveAlias(aliasStr, options, opts) {
			var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
			return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts), $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), !1)
		}

		var $ = __webpack_require__(4), window = __webpack_require__(6), document = window.document,
			generateMaskSet = __webpack_require__(7).generateMaskSet, analyseMask = __webpack_require__(7).analyseMask,
			maskScope = __webpack_require__(8);
		Inputmask.prototype = {
			dataAttribute: "data-inputmask",
			defaults: {
				placeholder: "_",
				optionalmarker: ["[", "]"],
				quantifiermarker: ["{", "}"],
				groupmarker: ["(", ")"],
				alternatormarker: "|",
				escapeChar: "\\",
				mask: null,
				regex: null,
				oncomplete: $.noop,
				onincomplete: $.noop,
				oncleared: $.noop,
				repeat: 0,
				greedy: !1,
				autoUnmask: !1,
				removeMaskOnSubmit: !1,
				clearMaskOnLostFocus: !0,
				insertMode: !0,
				clearIncomplete: !1,
				alias: null,
				onKeyDown: $.noop,
				onBeforeMask: null,
				onBeforePaste: function (pastedValue, opts) {
					return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue
				},
				onBeforeWrite: null,
				onUnMask: null,
				showMaskOnFocus: !0,
				showMaskOnHover: !0,
				onKeyValidation: $.noop,
				skipOptionalPartCharacter: " ",
				numericInput: !1,
				rightAlign: !1,
				undoOnEscape: !0,
				radixPoint: "",
				_radixDance: !1,
				groupSeparator: "",
				keepStatic: null,
				positionCaretOnTab: !0,
				tabThrough: !1,
				supportsInputType: ["text", "tel", "url", "password", "search"],
				ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
				isComplete: null,
				preValidation: null,
				postValidation: null,
				staticDefinitionSymbol: void 0,
				jitMasking: !1,
				nullable: !0,
				inputEventOnly: !1,
				noValuePatching: !1,
				positionCaretOnClick: "lvp",
				casing: null,
				inputmode: "verbatim",
				colorMask: !1,
				disablePredictiveText: !1,
				importDataAttributes: !0,
				shiftPositions: !0
			},
			definitions: {
				9: {validator: "[0-9１-９]", definitionSymbol: "*"},
				a: {validator: "[A-Za-zА-яЁёÀ-ÿµ]", definitionSymbol: "*"},
				"*": {validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ]"}
			},
			aliases: {},
			masksCache: {},
			mask: function (elems) {
				var that = this;
				return "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
					var scopedOpts = $.extend(!0, {}, that.opts);
					if (function (npt, opts, userOptions, dataAttribute) {
						function importOption(option, optionData) {
							null !== (optionData = void 0 !== optionData ? optionData : npt.getAttribute(dataAttribute + "-" + option)) && ("string" == typeof optionData && (0 === option.indexOf("on") ? optionData = window[optionData] : "false" === optionData ? optionData = !1 : "true" === optionData && (optionData = !0)), userOptions[option] = optionData)
						}

						if (!0 === opts.importDataAttributes) {
							var option, dataoptions, optionData, p, attrOptions = npt.getAttribute(dataAttribute);
							if (attrOptions && "" !== attrOptions && (attrOptions = attrOptions.replace(/'/g, '"'), dataoptions = JSON.parse("{" + attrOptions + "}")), dataoptions) for (p in optionData = void 0, dataoptions) if ("alias" === p.toLowerCase()) {
								optionData = dataoptions[p];
								break
							}
							for (option in importOption("alias", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts), opts) {
								if (dataoptions) for (p in optionData = void 0, dataoptions) if (p.toLowerCase() === option.toLowerCase()) {
									optionData = dataoptions[p];
									break
								}
								importOption(option, optionData)
							}
						}
						return $.extend(!0, opts, userOptions), "rtl" !== npt.dir && !opts.rightAlign || (npt.style.textAlign = "right"), "rtl" !== npt.dir && !opts.numericInput || (npt.dir = "ltr", npt.removeAttribute("dir"), opts.isRTL = !0), Object.keys(userOptions).length
					}(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute)) {
						var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
						void 0 !== maskset && (void 0 !== el.inputmask && (el.inputmask.opts.autoUnmask = !0, el.inputmask.remove()), el.inputmask = new Inputmask(void 0, void 0, !0), el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions), el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput, (el.inputmask.el = el).inputmask.maskset = maskset, $.data(el, "_inputmask_opts", scopedOpts), maskScope.call(el.inputmask, {action: "mask"}))
					}
				}), elems && elems[0] && elems[0].inputmask || this
			},
			option: function (options, noremask) {
				return "string" == typeof options ? this.opts[options] : "object" === _typeof(options) ? ($.extend(this.userOptions, options), this.el && !0 !== noremask && this.mask(this.el), this) : void 0
			},
			unmaskedvalue: function (value) {
				return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
					action: "unmaskedvalue",
					value: value
				})
			},
			remove: function () {
				return maskScope.call(this, {action: "remove"})
			},
			getemptymask: function () {
				return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {action: "getemptymask"})
			},
			hasMaskedValue: function () {
				return !this.opts.autoUnmask
			},
			isComplete: function () {
				return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {action: "isComplete"})
			},
			getmetadata: function () {
				return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {action: "getmetadata"})
			},
			isValid: function (value) {
				return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
					action: "isValid",
					value: value
				})
			},
			format: function (value, metadata) {
				return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
					action: "format",
					value: value,
					metadata: metadata
				})
			},
			setValue: function (value) {
				this.el && $(this.el).trigger("setvalue", [value])
			},
			analyseMask: analyseMask,
			positionColorMask: function (input, template) {
				input.style.left = template.offsetLeft + "px"
			}
		}, Inputmask.extendDefaults = function (options) {
			$.extend(!0, Inputmask.prototype.defaults, options)
		}, Inputmask.extendDefinitions = function (definition) {
			$.extend(!0, Inputmask.prototype.definitions, definition)
		}, Inputmask.extendAliases = function (alias) {
			$.extend(!0, Inputmask.prototype.aliases, alias)
		}, Inputmask.format = function (value, options, metadata) {
			return Inputmask(options).format(value, metadata)
		}, Inputmask.unmask = function (value, options) {
			return Inputmask(options).unmaskedvalue(value)
		}, Inputmask.isValid = function (value, options) {
			return Inputmask(options).isValid(value)
		}, Inputmask.remove = function (elems) {
			"string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
				el.inputmask && el.inputmask.remove()
			})
		}, Inputmask.setValue = function (elems, value) {
			"string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
				el.inputmask ? el.inputmask.setValue(value) : $(el).trigger("setvalue", [value])
			})
		}, Inputmask.escapeRegex = function (str) {
			return str.replace(new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim"), "\\$1")
		}, Inputmask.keyCode = {
			BACKSPACE: 8,
			BACKSPACE_SAFARI: 127,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			INSERT: 45,
			LEFT: 37,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38,
			X: 88,
			CONTROL: 17
		}, Inputmask.dependencyLib = $, window.Inputmask = Inputmask, module.exports = Inputmask
	}, function (module, exports, __webpack_require__) {
		module.exports = __webpack_require__(5)
	}, function (module, exports) {
		module.exports = __WEBPACK_EXTERNAL_MODULE__5__
	}, function (module, exports, __webpack_require__) {
		function _typeof(obj) {
			return (_typeof = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function (obj) {
				return void 0 === obj ? "undefined" : _typeof2(obj)
			} : function (obj) {
				return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : void 0 === obj ? "undefined" : _typeof2(obj)
			})(obj)
		}

		var __WEBPACK_AMD_DEFINE_RESULT__;
		__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return "undefined" != typeof window ? window : new (eval("require('jsdom').JSDOM"))("").window
		}.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
	}, function (module, exports, __webpack_require__) {
		var $ = __webpack_require__(4);
		module.exports = {
			generateMaskSet: function (opts, nocache) {
				function generateMask(mask, metadata, opts) {
					var masksetDefinition, maskdefKey, regexMask = !1;
					if (null !== mask && "" !== mask || (mask = (regexMask = null !== opts.regex) ? (mask = opts.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (regexMask = !0, ".*")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = ""), 0 < opts.repeat || "*" === opts.repeat || "+" === opts.repeat) {
						var repeatStart = "*" === opts.repeat ? 0 : "+" === opts.repeat ? 1 : opts.repeat;
						mask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + "," + opts.repeat + opts.quantifiermarker[1]
					}
					return maskdefKey = regexMask ? "regex_" + opts.regex : opts.numericInput ? mask.split("").reverse().join("") : mask, !1 !== opts.keepStatic && (maskdefKey = "ks_" + maskdefKey), void 0 === Inputmask.prototype.masksCache[maskdefKey] || !0 === nocache ? (masksetDefinition = {
						mask: mask,
						maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),
						validPositions: {},
						_buffer: void 0,
						buffer: void 0,
						tests: {},
						excludes: {},
						metadata: metadata,
						maskLength: void 0,
						jitOffset: {}
					}, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), masksetDefinition
				}

				if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {
					if (1 < opts.mask.length) {
						if (null === opts.keepStatic) {
							opts.keepStatic = "auto";
							for (var i = 0; i < opts.mask.length; i++) if (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {
								opts.keepStatic = !0;
								break
							}
						}
						var altMask = opts.groupmarker[0];
						return $.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {
							1 < altMask.length && (altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]), void 0 === msk.mask || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask
						}), generateMask(altMask += opts.groupmarker[1], opts.mask, opts)
					}
					opts.mask = opts.mask.pop()
				}
				return null === opts.keepStatic && (opts.keepStatic = !1), opts.mask && void 0 !== opts.mask.mask && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts)
			}, analyseMask: function (mask, regexMask, opts) {
				function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
					this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, this.quantifier = {
						min: 1,
						max: 1
					}
				}

				function insertTestDefinition(mtoken, element, position) {
					position = void 0 !== position ? position : mtoken.matches.length;
					var prevMatch = mtoken.matches[position - 1];
					if (regexMask) 0 === element.indexOf("[") || escaped && /\\d|\\s|\\w]/i.test(element) || "." === element ? mtoken.matches.splice(position++, 0, {
						fn: new RegExp(element, opts.casing ? "i" : ""),
						static: !1,
						optionality: !1,
						newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== element,
						casing: null,
						def: element,
						placeholder: void 0,
						nativeDef: element
					}) : (escaped && (element = element[element.length - 1]), $.each(element.split(""), function (ndx, lmnt) {
						prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {
							fn: /[a-z]/i.test(opts.staticDefinitionSymbol || lmnt) ? new RegExp("[" + (opts.staticDefinitionSymbol || lmnt) + "]", opts.casing ? "i" : "") : null,
							static: !0,
							optionality: !1,
							newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== lmnt && !0 !== prevMatch.static,
							casing: null,
							def: opts.staticDefinitionSymbol || lmnt,
							placeholder: void 0 !== opts.staticDefinitionSymbol ? lmnt : void 0,
							nativeDef: (escaped ? "'" : "") + lmnt
						})
					})), escaped = !1; else {
						var maskdef = (opts.definitions ? opts.definitions[element] : void 0) || Inputmask.prototype.definitions[element];
						maskdef && !escaped ? mtoken.matches.splice(position++, 0, {
							fn: maskdef.validator ? "string" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? "i" : "") : new function () {
								this.test = maskdef.validator
							} : new RegExp("."),
							static: !1,
							optionality: !1,
							newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== (maskdef.definitionSymbol || element),
							casing: maskdef.casing,
							def: maskdef.definitionSymbol || element,
							placeholder: maskdef.placeholder,
							nativeDef: element
						}) : (mtoken.matches.splice(position++, 0, {
							fn: /[a-z]/i.test(opts.staticDefinitionSymbol || element) ? new RegExp("[" + (opts.staticDefinitionSymbol || element) + "]", opts.casing ? "i" : "") : null,
							static: !0,
							optionality: !1,
							newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== element && !0 !== prevMatch.static,
							casing: null,
							def: opts.staticDefinitionSymbol || element,
							placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0,
							nativeDef: (escaped ? "'" : "") + element
						}), escaped = !1)
					}
				}

				function defaultCase() {
					if (0 < openenings.length) {
						if (insertTestDefinition(currentOpeningToken = openenings[openenings.length - 1], m), currentOpeningToken.isAlternator) {
							alternator = openenings.pop();
							for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup && (alternator.matches[mndx].isGroup = !1);
							0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator)
						}
					} else insertTestDefinition(currentToken, m)
				}

				function groupify(matches) {
					var groupToken = new MaskToken(!0);
					return groupToken.openGroup = !1, groupToken.matches = matches, groupToken
				}

				function closeGroup() {
					if ((openingToken = openenings.pop()).openGroup = !1, void 0 !== openingToken) if (0 < openenings.length) {
						if ((currentOpeningToken = openenings[openenings.length - 1]).matches.push(openingToken), currentOpeningToken.isAlternator) {
							alternator = openenings.pop();
							for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1, alternator.matches[mndx].alternatorGroup = !1;
							0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator)
						}
					} else currentToken.matches.push(openingToken); else defaultCase()
				}

				function groupQuantifier(matches) {
					var lastMatch = matches.pop();
					return lastMatch.isQuantifier && (lastMatch = groupify([matches.pop(), lastMatch])), lastMatch
				}

				var match, m, openingToken, currentOpeningToken, alternator, lastMatch,
					tokenizer = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g,
					regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
					escaped = !1, currentToken = new MaskToken, openenings = [], maskTokens = [], closeRegexGroup = !1;
				for (regexMask && (opts.optionalmarker[0] = void 0, opts.optionalmarker[1] = void 0); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask);) {
					if (m = match[0], regexMask) switch (m.charAt(0)) {
						case"?":
							m = "{0,1}";
							break;
						case"+":
						case"*":
							m = "{" + m + "}";
							break;
						case"|":
							if (0 === openenings.length) {
								var altRegexGroup = groupify(currentToken.matches);
								altRegexGroup.openGroup = !0, openenings.push(altRegexGroup), currentToken.matches = [], closeRegexGroup = !0
							}
					}
					if (escaped) defaultCase(); else switch (m.charAt(0)) {
						case"(?=":
						case"(?!":
						case"(?<=":
						case"(?<!":
							break;
						case opts.escapeChar:
							escaped = !0, regexMask && defaultCase();
							break;
						case opts.optionalmarker[1]:
						case opts.groupmarker[1]:
							closeGroup();
							break;
						case opts.optionalmarker[0]:
							openenings.push(new MaskToken(!1, !0));
							break;
						case opts.groupmarker[0]:
							openenings.push(new MaskToken(!0));
							break;
						case opts.quantifiermarker[0]:
							var quantifier = new MaskToken(!1, !1, !0), mqj = (m = m.replace(/[{}]/g, "")).split("|"),
								mq = mqj[0].split(","), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
								mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
							"*" !== mq0 && "+" !== mq0 || (mq0 = "*" === mq1 ? 0 : 1), quantifier.quantifier = {
								min: mq0,
								max: mq1,
								jit: mqj[1]
							};
							var matches = 0 < openenings.length ? openenings[openenings.length - 1].matches : currentToken.matches;
							if ((match = matches.pop()).isAlternator) {
								matches.push(match), matches = match.matches;
								var groupToken = new MaskToken(!0), tmpMatch = matches.pop();
								matches.push(groupToken), matches = groupToken.matches, match = tmpMatch
							}
							match.isGroup || (match = groupify([match])), matches.push(match), matches.push(quantifier);
							break;
						case opts.alternatormarker:
							if (0 < openenings.length) {
								var subToken = (currentOpeningToken = openenings[openenings.length - 1]).matches[currentOpeningToken.matches.length - 1];
								lastMatch = currentOpeningToken.openGroup && (void 0 === subToken.matches || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : groupQuantifier(currentOpeningToken.matches)
							} else lastMatch = groupQuantifier(currentToken.matches);
							if (lastMatch.isAlternator) openenings.push(lastMatch); else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), openenings.push(alternator), lastMatch.openGroup) {
								var alternatorGroup = new MaskToken(!(lastMatch.openGroup = !1));
								alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup)
							}
							break;
						default:
							defaultCase()
					}
				}
				for (closeRegexGroup && closeGroup(); 0 < openenings.length;) openingToken = openenings.pop(), currentToken.matches.push(openingToken);
				return 0 < currentToken.matches.length && (function verifyGroupMarker(maskToken) {
					maskToken && maskToken.matches && $.each(maskToken.matches, function (ndx, token) {
						var nextToken = maskToken.matches[ndx + 1];
						(void 0 === nextToken || void 0 === nextToken.matches || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, regexMask || (insertTestDefinition(token, opts.groupmarker[0], 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker[1]))), verifyGroupMarker(token)
					})
				}(currentToken), maskTokens.push(currentToken)), (opts.numericInput || opts.isRTL) && function reverseTokens(maskToken) {
					for (var match in maskToken.matches = maskToken.matches.reverse(), maskToken.matches) if (maskToken.matches.hasOwnProperty(match)) {
						var intMatch = parseInt(match);
						if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {
							var qt = maskToken.matches[match];
							maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt)
						}
						void 0 !== maskToken.matches[match].matches ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = ((st = maskToken.matches[match]) === opts.optionalmarker[0] ? st = opts.optionalmarker[1] : st === opts.optionalmarker[1] ? st = opts.optionalmarker[0] : st === opts.groupmarker[0] ? st = opts.groupmarker[1] : st === opts.groupmarker[1] && (st = opts.groupmarker[0]), st)
					}
					var st;
					return maskToken
				}(maskTokens[0]), maskTokens
			}
		}
	}, function (module, exports, __webpack_require__) {
		function _typeof(obj) {
			return (_typeof = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function (obj) {
				return void 0 === obj ? "undefined" : _typeof2(obj)
			} : function (obj) {
				return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : void 0 === obj ? "undefined" : _typeof2(obj)
			})(obj)
		}

		function isInputEventSupported(eventName) {
			var el = document.createElement("input"), evName = "on" + eventName, isSupported = evName in el;
			return isSupported || (el.setAttribute(evName, "return;"), isSupported = "function" == typeof el[evName]), el = null, isSupported
		}

		var $ = __webpack_require__(4), window = __webpack_require__(6), document = window.document,
			ua = window.navigator.userAgent, ie = 0 < ua.indexOf("MSIE ") || 0 < ua.indexOf("Trident/"),
			mobile = isInputEventSupported("touchstart"), iemobile = /iemobile/i.test(ua),
			iphone = /iphone/i.test(ua) && !iemobile;
		module.exports = function maskScope(actionObj, maskset, opts) {
			function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {
				var greedy = opts.greedy;
				clearOptionalTail && (opts.greedy = !1), minimalPos = minimalPos || 0;
				var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0;
				do {
					if (!0 === baseOnInput && maskset.validPositions[pos]) test = (testPos = clearOptionalTail && !0 === maskset.validPositions[pos].match.optionality && void 0 === maskset.validPositions[pos + 1] && (!0 === maskset.validPositions[pos].generatedInput || maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && 0 < pos) ? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1)) : maskset.validPositions[pos]).match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test)); else {
						test = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).match, ndxIntlzr = testPos.locator.slice();
						var jitMasking = !0 !== noJit && (!1 !== opts.jitMasking ? opts.jitMasking : test.jit);
						(!1 === jitMasking || void 0 === jitMasking || "number" == typeof jitMasking && isFinite(jitMasking) && pos < jitMasking) && maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))
					}
					"auto" === opts.keepStatic && test.newBlockMarker && !0 !== test.static && (opts.keepStatic = pos - 1), pos++
				} while ((void 0 === maxLength || pos < maxLength) && (!0 !== test.static || "" !== test.def) || pos < minimalPos);
				return "" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), !1 === includeMode && void 0 !== maskset.maskLength || (maskset.maskLength = pos - 1), opts.greedy = greedy, maskTemplate
			}

			function resetMaskSet(soft) {
				!(maskset.buffer = void 0) !== soft && (maskset.validPositions = {}, maskset.p = 0)
			}

			function getLastValidPosition(closestTo, strict, validPositions) {
				var before = -1, after = -1, valids = validPositions || maskset.validPositions;
				for (var posNdx in void 0 === closestTo && (closestTo = -1), valids) {
					var psNdx = parseInt(posNdx);
					valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), closestTo <= psNdx && (after = psNdx))
				}
				return -1 === before || before == closestTo ? after : -1 == after ? before : closestTo - before < after - closestTo ? before : after
			}

			function getDecisionTaker(tst) {
				var decisionTaker = tst.locator[tst.alternation];
				return "string" == typeof decisionTaker && 0 < decisionTaker.length && (decisionTaker = decisionTaker.split(",")[0]), void 0 !== decisionTaker ? decisionTaker.toString() : ""
			}

			function getLocator(tst, align) {
				var locator = (null != tst.alternation ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join("");
				if ("" !== locator) for (; locator.length < align;) locator += "0";
				return locator
			}

			function determineTestTemplate(pos, tests) {
				for (var tstLocator, closest, bestMatch, targetLocator = getLocator(getTest(pos = 0 < pos ? pos - 1 : 0)), ndx = 0; ndx < tests.length; ndx++) {
					var tst = tests[ndx];
					tstLocator = getLocator(tst, targetLocator.length);
					var distance = Math.abs(tstLocator - targetLocator);
					(void 0 === closest || "" !== tstLocator && distance < closest || bestMatch && !opts.greedy && bestMatch.match.optionality && "master" === bestMatch.match.newBlockMarker && (!tst.match.optionality || !tst.match.newBlockMarker) || bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier) && (closest = distance, bestMatch = tst)
				}
				return bestMatch
			}

			function getTestTemplate(pos, ndxIntlzr, tstPs) {
				return maskset.validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs))
			}

			function getTest(pos, tests) {
				return maskset.validPositions[pos] ? maskset.validPositions[pos] : (tests || getTests(pos))[0]
			}

			function positionCanMatchDefinition(pos, testDefinition, opts) {
				for (var valid = !1, tests = getTests(pos), defProp = opts.shiftPositions ? "def" : "nativeDef", tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match[defProp] === testDefinition.match[defProp]) {
					valid = !0;
					break
				}
				return !1 === valid && void 0 !== maskset.jitOffset[pos] && (valid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], testDefinition, opts)), valid
			}

			function getTests(pos, ndxIntlzr, tstPs) {
				function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
					function handleMatch(match, loopNdx, quantifierRecurse) {
						function isFirstMatch(latestMatch, tokenGroup) {
							var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);
							return firstMatch || $.each(tokenGroup.matches, function (ndx, match) {
								if (!0 === match.isQuantifier ? firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]) : match.hasOwnProperty("matches") && (firstMatch = isFirstMatch(latestMatch, match)), firstMatch) return !1
							}), firstMatch
						}

						function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
							var bestMatch, indexPos;
							if ((maskset.tests[pos] || maskset.validPositions[pos]) && $.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) {
								if (lmnt.mloc[alternateNdx]) return bestMatch = lmnt, !1;
								var alternation = void 0 !== targetAlternation ? targetAlternation : lmnt.alternation,
									ndxPos = void 0 !== lmnt.locator[alternation] ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
								(void 0 === indexPos || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, indexPos = ndxPos)
							}), bestMatch) {
								var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];
								return (bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator).slice((void 0 !== targetAlternation ? targetAlternation : bestMatch.alternation) + 1)
							}
							return void 0 !== targetAlternation ? resolveNdxInitializer(pos, alternateNdx) : void 0
						}

						function isSubsetOf(source, target) {
							function expand(pattern) {
								for (var end, expanded = [], start = -1, i = 0, l = pattern.length; i < l; i++) if ("-" === pattern.charAt(i)) for (end = pattern.charCodeAt(i + 1); ++start < end;) expanded.push(String.fromCharCode(start)); else start = pattern.charCodeAt(i), expanded.push(pattern.charAt(i));
								return expanded.join("")
							}

							return opts.regex && !0 !== source.match.static && !0 !== target.match.static ? -1 !== expand(target.match.def.replace(/[[\]]/g, "")).indexOf(expand(source.match.def.replace(/[[\]]/g, ""))) : source.match.def === target.match.nativeDef
						}

						function setMergeLocators(targetMatch, altMatch) {
							if (void 0 === altMatch || targetMatch.alternation === altMatch.alternation && -1 === targetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation])) {
								targetMatch.mloc = targetMatch.mloc || {};
								var locNdx = targetMatch.locator[targetMatch.alternation];
								if (void 0 !== locNdx) {
									if ("string" == typeof locNdx && (locNdx = locNdx.split(",")[0]), void 0 === targetMatch.mloc[locNdx] && (targetMatch.mloc[locNdx] = targetMatch.locator.slice()), void 0 !== altMatch) {
										for (var ndx in altMatch.mloc) "string" == typeof ndx && (ndx = ndx.split(",")[0]), void 0 === targetMatch.mloc[ndx] && (targetMatch.mloc[ndx] = altMatch.mloc[ndx]);
										targetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(",")
									}
									return !0
								}
								targetMatch.alternation = void 0
							}
							return !1
						}

						if (500 < testPos && void 0 !== quantifierRecurse) throw"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + maskset.mask;
						if (testPos === pos && void 0 === match.matches) return matches.push({
							match: match,
							locator: loopNdx.reverse(),
							cd: cacheDependency,
							mloc: {}
						}), !0;
						if (void 0 !== match.matches) {
							if (match.isGroup && quantifierRecurse !== match) {
								if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse)) return !0
							} else if (match.isOptional) {
								var optionalToken = match, mtchsNdx = matches.length;
								if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {
									if ($.each(matches, function (ndx, mtch) {
										mtchsNdx <= ndx && (mtch.match.optionality = !0)
									}), latestMatch = matches[matches.length - 1].match, void 0 !== quantifierRecurse || !isFirstMatch(latestMatch, optionalToken)) return !0;
									insertStop = !0, testPos = pos
								}
							} else if (match.isAlternator) {
								var maltMatches, alternateToken = match, malternateMatches = [],
									currentMatches = matches.slice(), loopNdxCnt = loopNdx.length,
									altIndex = 0 < ndxInitializer.length ? ndxInitializer.shift() : -1;
								if (-1 === altIndex || "string" == typeof altIndex) {
									var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(),
										altIndexArr = [];
									if ("string" == typeof altIndex) altIndexArr = altIndex.split(","); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx.toString());
									if (maskset.excludes[pos]) {
										for (var altIndexArrClone = altIndexArr.slice(), i = 0, el = maskset.excludes[pos].length; i < el; i++) altIndexArr.splice(altIndexArr.indexOf(maskset.excludes[pos][i].toString()), 1);
										0 === altIndexArr.length && (delete maskset.excludes[pos], altIndexArr = altIndexArrClone)
									}
									(!0 === opts.keepStatic || isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic) && (altIndexArr = altIndexArr.slice(0, 1));
									for (var unMatchedAlternation = !1, ndx = 0; ndx < altIndexArr.length; ndx++) {
										amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = "string" == typeof altIndex && resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(), alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) ? match = !0 : 0 === ndx && (unMatchedAlternation = !0), maltMatches = matches.slice(), testPos = currentPos, matches = [];
										for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
											var altMatch = maltMatches[ndx1], dropMatch = !1;
											altMatch.match.jit = altMatch.match.jit || unMatchedAlternation, altMatch.alternation = altMatch.alternation || loopNdxCnt, setMergeLocators(altMatch);
											for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
												var altMatch2 = malternateMatches[ndx2];
												if ("string" != typeof altIndex || void 0 !== altMatch.alternation && -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) {
													if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {
														dropMatch = !0, setMergeLocators(altMatch2, altMatch);
														break
													}
													if (isSubsetOf(altMatch, altMatch2)) {
														setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
														break
													}
													if (isSubsetOf(altMatch2, altMatch)) {
														setMergeLocators(altMatch2, altMatch);
														break
													}
													if (target = altMatch2, void 0, !(!((source = altMatch).locator.slice(source.alternation).join("") == target.locator.slice(target.alternation).join("")) || !0 !== source.match.static || !0 === target.match.static) && target.match.fn.test(source.match.def, maskset, pos, !1, opts, !1)) {
														setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
														break
													}
												}
											}
											dropMatch || malternateMatches.push(altMatch)
										}
									}
									matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = 0 < matches.length, match = 0 < malternateMatches.length, ndxInitializer = ndxInitializerClone.slice()
								} else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
								if (match) return !0
							} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {
								var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
								if (match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup)) {
									if ((latestMatch = matches[matches.length - 1].match).optionalQuantifier = qndx >= qt.quantifier.min, latestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit, latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {
										insertStop = !0, testPos = pos;
										break
									}
									return latestMatch.jit && (maskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch)), !0
								}
							} else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0
						} else testPos++;
						var source, target
					}

					for (var tndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (!0 !== maskToken.matches[tndx].isQuantifier) {
						var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
						if (match && testPos === pos) return match;
						if (pos < testPos) break
					}
				}

				var latestMatch, maskTokens = maskset.maskToken, testPos = ndxIntlzr ? tstPs : 0,
					ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0], matches = [], insertStop = !1,
					cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";
				if (-1 < pos && (void 0 === maxLength || pos < maxLength)) {
					if (void 0 === ndxIntlzr) {
						for (var test, previousPos = pos - 1; void 0 === (test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) && -1 < previousPos;) previousPos--;
						void 0 !== test && -1 < previousPos && (ndxInitializer = function (pos, tests) {
							var locator = [];
							return $.isArray(tests) || (tests = [tests]), 0 < tests.length && (void 0 === tests[0].alternation || !0 === opts.keepStatic ? 0 === (locator = determineTestTemplate(pos, tests.slice()).locator.slice()).length && (locator = tests[0].locator.slice()) : $.each(tests, function (ndx, tst) {
								if ("" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += "," + tst.locator[i])
							})), locator
						}(previousPos, test), cacheDependency = ndxInitializer.join(""), testPos = previousPos)
					}
					if (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) return maskset.tests[pos];
					for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
						if (resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]) && testPos === pos || pos < testPos) break
					}
				}
				return 0 !== matches.length && !insertStop || matches.push({
					match: {
						fn: null,
						static: !0,
						optionality: !1,
						casing: null,
						def: "",
						placeholder: ""
					}, locator: [], mloc: {}, cd: cacheDependency
				}), void 0 !== ndxIntlzr && maskset.tests[pos] ? $.extend(!0, [], matches) : (maskset.tests[pos] = $.extend(!0, [], matches), maskset.tests[pos])
			}

			function getBufferTemplate() {
				return void 0 === maskset._buffer && (maskset._buffer = getMaskTemplate(!1, 1), void 0 === maskset.buffer && (maskset.buffer = maskset._buffer.slice())), maskset._buffer
			}

			function getBuffer(noCache) {
				return void 0 !== maskset.buffer && !0 !== noCache || (maskset.buffer = getMaskTemplate(!0, getLastValidPosition(), !0), void 0 === maskset._buffer && (maskset._buffer = maskset.buffer.slice())), maskset.buffer
			}

			function refreshFromBuffer(start, end, buffer) {
				var i, p;
				if (!0 === start) resetMaskSet(), maskset.tests = {}, start = 0, end = buffer.length; else for (i = start; i < end; i++) delete maskset.validPositions[i];
				for (i = p = start; i < end; i++) if (buffer[i] !== opts.skipOptionalPartCharacter) {
					var valResult = isValid(p, buffer[i], !opts.negationSymbol || [i] !== opts.negationSymbol.front, !opts.negationSymbol || [i] !== opts.negationSymbol.front);
					!1 !== valResult && (p = void 0 !== valResult.caret ? valResult.caret : valResult.pos + 1)
				}
			}

			function checkAlternationMatch(altArr1, altArr2, na) {
				for (var naNdx, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = void 0 !== na ? na.split(",") : [], i = 0; i < naArr.length; i++) -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);
				for (var alndx = 0; alndx < altArr1.length; alndx++) if (-1 !== $.inArray(altArr1[alndx], altArrC)) {
					isMatch = !0;
					break
				}
				return isMatch
			}

			function alternate(pos, c, strict, fromIsValid, rAltPos) {
				function insertPosition(insert) {
					if (insert && isValidRslt && void 0 !== c) {
						var targetLvp = getLastValidPosition(pos) + 1;
						for (i = decisionPos; i < getLastValidPosition() + 1; i++) (void 0 === (validPos = maskset.validPositions[i]) || 1 == validPos.match.static) && i < pos + posOffset && posOffset++;
						isValidRslt = returnRslt = isValid(targetLvp < (pos += posOffset) ? targetLvp : pos, c, strict, fromIsValid, !0)
					}
				}

				var lastAlt, alternation, altPos, prevAltPos, i, validPos, decisionPos,
					validPsClone = $.extend(!0, {}, maskset.validPositions), isValidRslt = !1, returnRslt = !1,
					lAltPos = void 0 !== rAltPos ? rAltPos : getLastValidPosition();
				if (-1 === lAltPos && void 0 === rAltPos) alternation = (prevAltPos = getTest(lastAlt = 0)).alternation; else for (; 0 <= lAltPos; lAltPos--) if ((altPos = maskset.validPositions[lAltPos]) && void 0 !== altPos.alternation) {
					if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;
					lastAlt = lAltPos, alternation = maskset.validPositions[lastAlt].alternation, prevAltPos = altPos
				}
				if (void 0 !== alternation) {
					decisionPos = parseInt(lastAlt), maskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [], !0 !== pos && maskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos));
					var validInputsClone = [], staticInputsBeforePos = 0;
					for (i = decisionPos; i < getLastValidPosition(void 0, !0) + 1; i++) (validPos = maskset.validPositions[i]) && !0 !== validPos.generatedInput ? validInputsClone.push(validPos.input) : i < pos && staticInputsBeforePos++, delete maskset.validPositions[i];
					for (; maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10;) {
						var posOffset = -1 * staticInputsBeforePos, validInputs = validInputsClone.slice();
						for (resetMaskSet(!(maskset.tests[decisionPos] = void 0)), isValidRslt = !0, insertPosition(0 === pos); 0 < validInputs.length;) {
							var input = validInputs.shift();
							if (!(isValidRslt = isValid(isValidRslt.caret || getLastValidPosition(void 0, !0) + 1, input, !1, fromIsValid, !0))) break
						}
						if (insertPosition(0 < pos), isValidRslt) break;
						if (resetMaskSet(), prevAltPos = getTest(decisionPos), maskset.validPositions = $.extend(!0, {}, validPsClone), !maskset.excludes[decisionPos]) {
							returnRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);
							break
						}
						var decisionTaker = getDecisionTaker(prevAltPos);
						if (-1 !== maskset.excludes[decisionPos].indexOf(decisionTaker)) {
							returnRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);
							break
						}
						for (maskset.excludes[decisionPos].push(decisionTaker), i = decisionPos; i < getLastValidPosition(void 0, !0) + 1; i++) delete maskset.validPositions[i]
					}
				}
				return delete maskset.excludes[decisionPos], returnRslt
			}

			function isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) {
				function isSelection(posObj) {
					return isRTL ? 1 < posObj.begin - posObj.end || posObj.begin - posObj.end == 1 : 1 < posObj.end - posObj.begin || posObj.end - posObj.begin == 1
				}

				function processCommandObject(commandObj) {
					if (void 0 !== commandObj) {
						if (void 0 !== commandObj.remove && ($.isArray(commandObj.remove) || (commandObj.remove = [commandObj.remove]), $.each(commandObj.remove.sort(function (a, b) {
							return b.pos - a.pos
						}), function (ndx, lmnt) {
							revalidateMask({begin: lmnt, end: lmnt + 1})
						}), commandObj.remove = void 0), void 0 !== commandObj.insert && ($.isArray(commandObj.insert) || (commandObj.insert = [commandObj.insert]), $.each(commandObj.insert.sort(function (a, b) {
							return a.pos - b.pos
						}), function (ndx, lmnt) {
							"" !== lmnt.c && isValid(lmnt.pos, lmnt.c, void 0 === lmnt.strict || lmnt.strict, void 0 !== lmnt.fromIsValid ? lmnt.fromIsValid : fromIsValid)
						}), commandObj.insert = void 0), commandObj.refreshFromBuffer && commandObj.buffer) {
							var refresh = commandObj.refreshFromBuffer;
							refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, commandObj.buffer), commandObj.refreshFromBuffer = void 0
						}
						void 0 !== commandObj.rewritePosition && (maskPos = commandObj.rewritePosition, (commandObj = !0).rewritePosition = void 0)
					}
					return commandObj
				}

				function _isValid(position, c, strict) {
					var rslt = !1;
					return $.each(getTests(position), function (ndx, tst) {
						var test = tst.match;
						if (getBuffer(!0), !1 !== (rslt = null != test.fn ? test.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && "" !== test.def && {
							c: getPlaceholder(position, test, !0) || test.def,
							pos: position
						})) {
							var elem = void 0 !== rslt.c ? rslt.c : c, validatedPos = position;
							return elem = elem === opts.skipOptionalPartCharacter && !0 === test.static ? getPlaceholder(position, test, !0) || test.def : elem, !0 !== (rslt = processCommandObject(rslt)) && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos), !0 !== rslt && void 0 === rslt.pos && void 0 === rslt.c || revalidateMask(pos, $.extend({}, tst, {
								input: function (elem, test, pos) {
									switch (opts.casing || test.casing) {
										case"upper":
											elem = elem.toUpperCase();
											break;
										case"lower":
											elem = elem.toLowerCase();
											break;
										case"title":
											var posBefore = maskset.validPositions[pos - 1];
											elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();
											break;
										default:
											if ($.isFunction(opts.casing)) {
												var args = Array.prototype.slice.call(arguments);
												args.push(maskset.validPositions), elem = opts.casing.apply(this, args)
											}
									}
									return elem
								}(elem, test, validatedPos)
							}), fromIsValid, validatedPos) || (rslt = !1), !1
						}
					}), rslt
				}

				strict = !0 === strict;
				var maskPos = pos;
				void 0 !== pos.begin && (maskPos = isRTL ? pos.end : pos.begin);
				var result = !0, positionsClone = $.extend(!0, {}, maskset.validPositions);
				if ($.isFunction(opts.preValidation) && !strict && !0 !== fromIsValid && !0 !== validateOnly && !0 !== fromAlternate && (result = processCommandObject(result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, maskset, pos))), !0 === result) {
					if ((void 0 === maxLength || maskPos < maxLength) && (result = _isValid(maskPos, c, strict), (!strict || !0 === fromIsValid) && !1 === result && !0 !== validateOnly)) {
						var currentPosValid = maskset.validPositions[maskPos];
						if (!currentPosValid || !0 !== currentPosValid.match.static || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {
							if (opts.insertMode || void 0 === maskset.validPositions[seekNext(maskPos)] || pos.end > maskPos) {
								var skip = !1;
								if (maskset.jitOffset[maskPos] && void 0 === maskset.validPositions[seekNext(maskPos)] && (!1 !== (result = isValid(maskPos + maskset.jitOffset[maskPos], c, !0)) && (!0 !== fromAlternate && (result.caret = maskPos), skip = !0)), pos.end > maskPos && (maskset.validPositions[maskPos] = void 0), !skip && !isMask(maskPos, !0)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (!1 !== (result = _isValid(nPos, c, strict))) {
									result = trackbackPositions(maskPos, void 0 !== result.pos ? result.pos : nPos) || result, maskPos = nPos;
									break
								}
							}
						} else result = {caret: seekNext(maskPos)}
					}
					!1 !== result || !1 === opts.keepStatic || null != opts.regex && !isComplete(getBuffer()) || strict || !0 === fromAlternate || (result = alternate(maskPos, c, strict, fromIsValid)), !0 === result && (result = {pos: maskPos})
				}
				if ($.isFunction(opts.postValidation) && !1 !== result && !strict && !0 !== fromIsValid && !0 !== validateOnly) {
					var postResult = opts.postValidation(getBuffer(!0), void 0 !== pos.begin ? isRTL ? pos.end : pos.begin : pos, result, opts);
					void 0 !== postResult && (result = !0 === postResult ? result : postResult)
				}
				return result && void 0 === result.pos && (result.pos = maskPos), !1 === result || !0 === validateOnly ? (resetMaskSet(!0), maskset.validPositions = $.extend(!0, {}, positionsClone)) : trackbackPositions(void 0, maskPos, !0), processCommandObject(result)
			}

			function trackbackPositions(originalPos, newPos, fillOnly) {
				if (void 0 === originalPos) for (originalPos = newPos - 1; 0 < originalPos && !maskset.validPositions[originalPos]; originalPos--) ;
				for (var ps = originalPos; ps < newPos; ps++) {
					if (void 0 === maskset.validPositions[ps] && !isMask(ps, !0)) if (0 == ps ? getTest(ps) : maskset.validPositions[ps - 1]) {
						var tests = getTests(ps).slice();
						"" === tests[tests.length - 1].match.def && tests.pop();
						var np, bestMatch = determineTestTemplate(ps, tests);
						if (bestMatch && (!0 !== bestMatch.match.jit || "master" === bestMatch.match.newBlockMarker && (np = maskset.validPositions[ps + 1]) && !0 === np.match.optionalQuantifier) && ((bestMatch = $.extend({}, bestMatch, {input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def})).generatedInput = !0, revalidateMask(ps, bestMatch, !0), !0 !== fillOnly)) return isValid(newPos, maskset.validPositions[newPos].input, !(maskset.validPositions[newPos] = void 0), !0)
					}
				}
			}

			function revalidateMask(pos, validTest, fromIsValid, validatedPos) {
				function IsEnclosedStatic(pos, valids, selection) {
					var posMatch = valids[pos];
					if (void 0 === posMatch || (!0 !== posMatch.match.static || !0 === posMatch.match.optionality) && posMatch.input !== opts.radixPoint) return !1;
					var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && !0 === valids[pos - 1].match.static && valids[pos - 1] : valids[pos - 1],
						nextMatch = selection.end > pos + 1 ? valids[pos + 1] && !0 === valids[pos + 1].match.static && valids[pos + 1] : valids[pos + 1];
					return prevMatch && nextMatch
				}

				var begin = void 0 !== pos.begin ? pos.begin : pos, end = void 0 !== pos.end ? pos.end : pos;
				if (pos.begin > pos.end && (begin = pos.end, end = pos.begin), validatedPos = void 0 !== validatedPos ? validatedPos : begin, begin !== end || opts.insertMode && void 0 !== maskset.validPositions[validatedPos] && void 0 === fromIsValid) {
					var i, positionsClone = $.extend(!0, {}, maskset.validPositions),
						lvp = getLastValidPosition(void 0, !0);
					for (maskset.p = begin, i = lvp; begin <= i; i--) delete maskset.validPositions[i], void 0 === validTest && delete maskset.tests[i + 1];
					var valid = !0, j = validatedPos, posMatch = j;
					for (i = j, validTest && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest), posMatch++, j++, begin < end && i++); i <= lvp; i++) {
						var t = positionsClone[i];
						if (void 0 !== t && !0 !== t.generatedInput && (end <= i || begin <= i && IsEnclosedStatic(i, positionsClone, {
							begin: begin,
							end: end
						}))) {
							for (; "" !== getTest(posMatch).match.def;) {
								if (positionCanMatchDefinition(posMatch, t, opts) || "+" === t.match.def) {
									"+" === t.match.def && getBuffer(!0);
									var result = isValid(posMatch, t.input, "+" !== t.match.def, "+" !== t.match.def);
									if (valid = !1 !== result, j = (result.pos || posMatch) + 1, !valid) break
								} else valid = !0 === t.generatedInput;
								if (valid) break;
								if (!valid && posMatch > maskset.maskLength) break;
								posMatch++
							}
							"" == getTest(posMatch).match.def && (valid = !1), posMatch = j
						}
						if (!valid) break
					}
					if (!valid) return maskset.validPositions = $.extend(!0, {}, positionsClone), resetMaskSet(!0), !1
				} else validTest && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest));
				return resetMaskSet(!0), !0
			}

			function isMask(pos, strict) {
				var test = getTestTemplate(pos).match;
				if ("" === test.def && (test = getTest(pos).match), 1 != test.static) return test.fn;
				if (!0 !== strict && -1 < pos) {
					var tests = getTests(pos);
					return tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0)
				}
				return !1
			}

			function seekNext(pos, newBlock) {
				for (var position = pos + 1; "" !== getTest(position).match.def && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position)) || !0 !== newBlock && !isMask(position));) position++;
				return position
			}

			function seekPrevious(pos, newBlock) {
				var tests, position = pos;
				if (position <= 0) return 0;
				for (; 0 < --position && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position) && ((tests = getTests(position)).length < 2 || 2 === tests.length && "" === tests[1].match.def));) ;
				return position
			}

			function writeBuffer(input, buffer, caretPos, event, triggerEvents) {
				if (event && $.isFunction(opts.onBeforeWrite)) {
					var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
					if (result) {
						if (result.refreshFromBuffer) {
							var refresh = result.refreshFromBuffer;
							refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), buffer = getBuffer(!0)
						}
						void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos)
					}
				}
				if (void 0 !== input && (input.inputmask._valueSet(buffer.join("")), void 0 === caretPos || void 0 !== event && "blur" === event.type ? renderColorMask(input, caretPos, 0 === buffer.length) : caret(input, caretPos), !0 === triggerEvents)) {
					var $input = $(input), nptVal = input.inputmask._valueGet();
					skipInputEvent = !0, $input.trigger("input"), setTimeout(function () {
						nptVal === getBufferTemplate().join("") ? $input.trigger("cleared") : !0 === isComplete(buffer) && $input.trigger("complete")
					}, 0)
				}
			}

			function getPlaceholder(pos, test, returnPL) {
				if (void 0 !== (test = test || getTest(pos).match).placeholder || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;
				if (!0 !== test.static) return opts.placeholder.charAt(pos % opts.placeholder.length);
				if (-1 < pos && void 0 === maskset.validPositions[pos]) {
					var prevTest, tests = getTests(pos), staticAlternations = [];
					if (tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if (!0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (!0 === tests[i].match.static || void 0 === prevTest || !1 !== tests[i].match.fn.test(prevTest.match.def, maskset, pos, !0, opts)) && (staticAlternations.push(tests[i]), !0 === tests[i].match.static && (prevTest = tests[i]), 1 < staticAlternations.length && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length)
				}
				return test.def
			}

			function HandleNativePlaceholder(npt, value) {
				if (ie) {
					if (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || "" === npt.placeholder)) {
						var buffer = getBuffer().slice(), nptValue = npt.inputmask._valueGet();
						if (nptValue !== value) {
							var lvp = getLastValidPosition();
							-1 === lvp && nptValue === getBufferTemplate().join("") ? buffer = [] : -1 !== lvp && clearOptionalTail(buffer), writeBuffer(npt, buffer)
						}
					}
				} else npt.placeholder !== value && (npt.placeholder = value, "" === npt.placeholder && npt.removeAttribute("placeholder"))
			}

			function determineNewCaretPosition(selectedCaret, tabbed) {
				if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), selectedCaret.begin === selectedCaret.end) switch (opts.positionCaretOnClick) {
					case"none":
						break;
					case"select":
						return {begin: 0, end: getBuffer().length};
					case"ignore":
						return seekNext(getLastValidPosition());
					case"radixFocus":
						if (function (clickPos) {
							if ("" !== opts.radixPoint) {
								var vps = maskset.validPositions;
								if (void 0 === vps[clickPos] || vps[clickPos].input === getPlaceholder(clickPos)) {
									if (clickPos < seekNext(-1)) return !0;
									var radixPos = $.inArray(opts.radixPoint, getBuffer());
									if (-1 !== radixPos) {
										for (var vp in vps) if (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;
										return !0
									}
								}
							}
							return !1
						}(selectedCaret.begin)) {
							var radixPos = getBuffer().join("").indexOf(opts.radixPoint);
							return opts.numericInput ? seekNext(radixPos) : radixPos
						}
					default:
						var clickPosition = selectedCaret.begin,
							lvclickPosition = getLastValidPosition(clickPosition, !0),
							lastPosition = seekNext(-1 !== lvclickPosition || isMask(0) ? lvclickPosition : 0);
						if (clickPosition < lastPosition) return isMask(clickPosition, !0) || isMask(clickPosition - 1, !0) ? clickPosition : seekNext(clickPosition);
						var lvp = maskset.validPositions[lvclickPosition],
							tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : void 0, lvp),
							placeholder = getPlaceholder(lastPosition, tt.match);
						if ("" !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder) {
							var newPos = seekNext(lastPosition);
							(newPos <= clickPosition || clickPosition === lastPosition) && (lastPosition = newPos)
						}
						return lastPosition
				}
			}

			function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
				var inputmask = this || input.inputmask, inputValue = nptvl.slice(), charCodes = "", initialNdx = -1,
					result = void 0;
				resetMaskSet(), initialNdx = opts.radixPoint ? determineNewCaretPosition(0) : 0, maskset.p = initialNdx, inputmask.caretPos = {begin: initialNdx};
				var sndx, validPos, nextValid, staticMatches = [], prevCaretPos = inputmask.caretPos;
				if ($.each(inputValue, function (ndx, charCode) {
					if (void 0 !== charCode) if (void 0 === maskset.validPositions[ndx] && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, !0) && !1 === isValid(ndx, inputValue[ndx], !0, void 0, void 0, !0)) maskset.p++; else {
						var keypress = new $.Event("_checkval");
						keypress.which = charCode.charCodeAt(0), charCodes += charCode;
						var lvp = getLastValidPosition(void 0, !0);
						!function (ndx, charCodes) {
							if (opts.regex) return !1;
							for (var targetTemplate = getMaskTemplate(!0, 0, !1).slice(ndx, seekNext(ndx)).join("").replace(/'/g, ""), charCodeNdx = targetTemplate.indexOf(charCodes); 0 < charCodeNdx && " " === targetTemplate[charCodeNdx - 1];) charCodeNdx--;
							var match = 0 === charCodeNdx && !isMask(ndx) && (getTest(ndx).match.nativeDef === charCodes.charAt(0) || !0 === getTest(ndx).match.static && getTest(ndx).match.nativeDef === "'" + charCodes.charAt(0) || " " === getTest(ndx).match.nativeDef && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0) || !0 === getTest(ndx + 1).match.static && getTest(ndx + 1).match.nativeDef === "'" + charCodes.charAt(0)));
							return !match && 0 < charCodeNdx && (inputmask.caretPos = {begin: seekNext(charCodeNdx)}), match
						}(initialNdx, charCodes) ? (result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, inputmask.caretPos.begin)) && (initialNdx = inputmask.caretPos.begin + 1, charCodes = "") : result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, lvp + 1), result ? (void 0 !== result.pos && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static && (staticMatches.push(result.pos), isRTL || (result.forwardPosition = result.pos + 1)), writeBuffer(void 0, getBuffer(), result.forwardPosition, keypress, !1), inputmask.caretPos = {
							begin: result.forwardPosition,
							end: result.forwardPosition
						}, prevCaretPos = inputmask.caretPos) : inputmask.caretPos = prevCaretPos
					}
				}), 0 < staticMatches.length) if (!isComplete(getBuffer()) || staticMatches.length < seekNext(0)) for (; void 0 !== (sndx = staticMatches.pop());) {
					var keypress = new $.Event("_checkval"), nextSndx = sndx + 1;
					for ((validPos = maskset.validPositions[sndx]).generatedInput = !0, keypress.which = validPos.input.charCodeAt(0); (nextValid = maskset.validPositions[nextSndx]) && nextValid.input === validPos.input;) nextSndx++;
					(result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, nextSndx)) && void 0 !== result.pos && result.pos !== sndx && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static && staticMatches.push(result.pos)
				} else for (; sndx = staticMatches.pop();) (validPos = maskset.validPositions[sndx]) && (validPos.generatedInput = !0);
				writeOut && writeBuffer(input, getBuffer(), result ? result.forwardPosition : void 0, initiatingEvent || new $.Event("checkval"), initiatingEvent && "input" === initiatingEvent.type)
			}

			function unmaskedvalue(input) {
				if (input) {
					if (void 0 === input.inputmask) return input.value;
					input.inputmask && input.inputmask.refreshValue && applyInputValue(input, input.inputmask._valueGet(!0))
				}
				var umValue = [], vps = maskset.validPositions;
				for (var pndx in vps) vps[pndx] && vps[pndx].match && 1 != vps[pndx].match.static && umValue.push(vps[pndx].input);
				var unmaskedValue = 0 === umValue.length ? "" : (isRTL ? umValue.reverse() : umValue).join("");
				if ($.isFunction(opts.onUnMask)) {
					var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
					unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts)
				}
				return unmaskedValue
			}

			function caret(input, begin, end, notranslate) {
				function translatePosition(pos) {
					return !isRTL || "number" != typeof pos || opts.greedy && "" === opts.placeholder || !el || (pos = el.inputmask._valueGet().length - pos), pos
				}

				var range;
				if (void 0 === begin) return "selectionStart" in input && "selectionEnd" in input ? (begin = input.selectionStart, end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, end = range.endOffset) : document.selection && document.selection.createRange && (end = (begin = 0 - (range = document.selection.createRange()).duplicate().moveStart("character", -input.inputmask._valueGet().length)) + range.text.length), !1 === opts.insertMode && begin === end - 1 && end--, {
					begin: notranslate ? begin : translatePosition(begin),
					end: notranslate ? end : translatePosition(end)
				};
				if ($.isArray(begin) && (end = isRTL ? begin[0] : begin[1], begin = isRTL ? begin[1] : begin[0]), void 0 !== begin.begin && (end = isRTL ? begin.begin : begin.end, begin = isRTL ? begin.end : begin.begin), "number" == typeof begin) {
					begin = notranslate ? begin : translatePosition(begin), end = "number" == typeof (end = notranslate ? end : translatePosition(end)) ? end : begin;
					var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
					if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, !(input.inputmask.caretPos = {
						begin: begin,
						end: end
					}) === opts.insertMode && begin === end && end++, input === document.activeElement) {
						if ("setSelectionRange" in input) input.setSelectionRange(begin, end); else if (window.getSelection) {
							if (range = document.createRange(), void 0 === input.firstChild || null === input.firstChild) {
								var textNode = document.createTextNode("");
								input.appendChild(textNode)
							}
							range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), range.collapse(!0);
							var sel = window.getSelection();
							sel.removeAllRanges(), sel.addRange(range)
						} else input.createTextRange && ((range = input.createTextRange()).collapse(!0), range.moveEnd("character", end), range.moveStart("character", begin), range.select());
						renderColorMask(input, {begin: begin, end: end})
					}
				}
			}

			function determineLastRequiredPosition(returnDefinition) {
				var pos, testPos, buffer = getMaskTemplate(!0, getLastValidPosition(), !0, !0), bl = buffer.length,
					lvp = getLastValidPosition(), positions = {}, lvTest = maskset.validPositions[lvp],
					ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0;
				for (pos = lvp + 1; pos < buffer.length; pos++) ndxIntlzr = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).locator.slice(), positions[pos] = $.extend(!0, {}, testPos);
				var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;
				for (pos = bl - 1; lvp < pos && (((testPos = positions[pos]).match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && 1 != testPos.match.static || !0 === testPos.match.static && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && "" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;
				return returnDefinition ? {l: bl, def: positions[bl] ? positions[bl].match : void 0} : bl
			}

			function clearOptionalTail(buffer) {
				for (var lmnt, template = getMaskTemplate(!(buffer.length = 0), 0, !0, void 0, !0); void 0 !== (lmnt = template.shift());) buffer.push(lmnt);
				return buffer
			}

			function isComplete(buffer) {
				if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
				if ("*" !== opts.repeat) {
					var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);
					if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
						complete = !0;
						for (var i = 0; i <= aml; i++) {
							var test = getTestTemplate(i).match;
							if (!0 !== test.static && void 0 === maskset.validPositions[i] && !0 !== test.optionality && !0 !== test.optionalQuantifier || !0 === test.static && buffer[i] !== getPlaceholder(i, test)) {
								complete = !1;
								break
							}
						}
					}
					return complete
				}
			}

			function handleRemove(input, k, pos, strict, fromIsValid) {
				if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE), isRTL)) {
					var pend = pos.end;
					pos.end = pos.begin, pos.begin = pend
				}
				if (k === Inputmask.keyCode.BACKSPACE && pos.end - pos.begin < 1 ? (pos.begin = seekPrevious(pos.begin), void 0 !== maskset.validPositions[pos.begin] && maskset.validPositions[pos.begin].input === opts.groupSeparator && pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0) && maskset.validPositions[pos.end] && maskset.validPositions[pos.end].input !== opts.radixPoint ? pos.end + 1 : seekNext(pos.end) + 1, void 0 !== maskset.validPositions[pos.begin] && maskset.validPositions[pos.begin].input === opts.groupSeparator && pos.end++), revalidateMask(pos), !0 !== strict && !1 !== opts.keepStatic || null !== opts.regex && -1 !== getTest(pos.begin).match.def.indexOf("|")) {
					var result = alternate(!0);
					if (result) {
						var newPos = void 0 !== result.caret ? result.caret : result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, !0);
						(k !== Inputmask.keyCode.DELETE || pos.begin > newPos) && pos.begin
					}
				}
				var lvp = getLastValidPosition(pos.begin, !0);
				if (lvp < pos.begin || -1 === pos.begin) maskset.p = seekNext(lvp); else if (!0 !== strict && (maskset.p = pos.begin, !0 !== fromIsValid)) for (; maskset.p < lvp && void 0 === maskset.validPositions[maskset.p];) maskset.p++
			}

			function initializeColorMask(input) {
				var computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null),
					template = document.createElement("div");
				template.style.width = computedStyle.width, template.style.textAlign = computedStyle.textAlign, colorMask = document.createElement("div"), (input.inputmask.colorMask = colorMask).className = "im-colormask", input.parentNode.insertBefore(colorMask, input), input.parentNode.removeChild(input), colorMask.appendChild(input), colorMask.appendChild(template), input.style.left = template.offsetLeft + "px", $(colorMask).on("mouseleave", function (e) {
					return EventHandlers.mouseleaveEvent.call(input, [e])
				}), $(colorMask).on("mouseenter", function (e) {
					return EventHandlers.mouseenterEvent.call(input, [e])
				}), $(colorMask).on("click", function (e) {
					return caret(input, function (clientx) {
						var caretPos, e = document.createElement("span");
						for (var style in computedStyle) isNaN(style) && -1 !== style.indexOf("font") && (e.style[style] = computedStyle[style]);
						e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing, e.style.position = "absolute", e.style.height = "auto", e.style.width = "auto", e.style.visibility = "hidden", e.style.whiteSpace = "nowrap", document.body.appendChild(e);
						var itl, inputText = input.inputmask._valueGet(), previousWidth = 0;
						for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {
							if (e.innerHTML += inputText.charAt(caretPos) || "_", e.offsetWidth >= clientx) {
								var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;
								e.innerHTML = inputText.charAt(caretPos), caretPos = (offset1 -= e.offsetWidth / 3) < offset2 ? caretPos - 1 : caretPos;
								break
							}
							previousWidth = e.offsetWidth
						}
						return document.body.removeChild(e), caretPos
					}(e.clientX)), EventHandlers.clickEvent.call(input, [e])
				})
			}

			function renderColorMask(input, caretPos, clear) {
				function setEntry(entry) {
					if (void 0 === entry && (entry = ""), isStatic || !0 !== test.static && void 0 !== testPos.input) if (isStatic && (!0 !== test.static && void 0 !== testPos.input || "" === test.def)) {
						isStatic = !1;
						var mtl = maskTemplate.length;
						maskTemplate[mtl - 1] = maskTemplate[mtl - 1] + "</span>", maskTemplate.push(entry)
					} else maskTemplate.push(entry); else isStatic = !0, maskTemplate.push("<span class='im-static'>" + entry)
				}

				var test, testPos, ndxIntlzr, maskTemplate = [], isStatic = !1, pos = 0;
				if (void 0 !== colorMask) {
					var buffer = getBuffer();
					if (void 0 === caretPos ? caretPos = caret(input) : void 0 === caretPos.begin && (caretPos = {
						begin: caretPos,
						end: caretPos
					}), !0 !== clear) {
						var lvp = getLastValidPosition();
						do {
							if (maskset.validPositions[pos]) testPos = maskset.validPositions[pos], test = testPos.match, ndxIntlzr = testPos.locator.slice(), setEntry(buffer[pos]); else {
								testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), test = testPos.match, ndxIntlzr = testPos.locator.slice();
								var jitMasking = !1 !== opts.jitMasking ? opts.jitMasking : test.jit;
								!1 === jitMasking || void 0 === jitMasking || "number" == typeof jitMasking && isFinite(jitMasking) && pos < jitMasking ? setEntry(getPlaceholder(pos, test)) : isStatic = !1
							}
							pos++
						} while ((void 0 === maxLength || pos < maxLength) && (!0 !== test.static || "" !== test.def) || pos < lvp || isStatic);
						isStatic && setEntry(), document.activeElement === input && (maskTemplate.splice(caretPos.begin, 0, caretPos.begin === caretPos.end || caretPos.end > maskset.maskLength ? '<mark class="im-caret" style="border-right-width: 1px;border-right-style: solid;">' : '<mark class="im-caret-select">'), maskTemplate.splice(caretPos.end + 1, 0, "</mark>"))
					}
					var template = colorMask.getElementsByTagName("div")[0];
					template.innerHTML = maskTemplate.join(""), input.inputmask.positionColorMask(input, template)
				}
			}

			function applyInputValue(input, value) {
				input.inputmask.refreshValue = !1, $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value), checkVal(input, !0, !1, value = value.toString().split("")), undoValue = getBuffer().join(""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("") && -1 === getLastValidPosition() && input.inputmask._valueSet("")
			}

			maskset = maskset || this.maskset, opts = opts || this.opts;
			var undoValue, $el, maxLength, colorMask, valueBuffer, inputmask = this, el = this.el,
				isRTL = this.isRTL || (this.isRTL = opts.numericInput), skipKeyPressEvent = !1, skipInputEvent = !1,
				ignorable = !1, mouseEnter = !1, originalPlaceholder = void 0, EventRuler = {
					on: function (input, eventName, eventHandler) {
						var ev = function (e) {
							var args, that = this;
							if (void 0 === that.inputmask && "FORM" !== this.nodeName) {
								var imOpts = $.data(that, "_inputmask_opts");
								imOpts ? new Inputmask(imOpts).mask(that) : EventRuler.off(that)
							} else {
								if ("setvalue" === e.type || "FORM" === this.nodeName || !(that.disabled || that.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === Inputmask.keyCode.TAB))) {
									switch (e.type) {
										case"input":
											if (!0 === skipInputEvent) return skipInputEvent = !1, e.preventDefault();
											if (mobile) return args = arguments, setTimeout(function () {
												eventHandler.apply(that, args), caret(that, that.inputmask.caretPos, void 0, !0)
											}, 0), !1;
											break;
										case"keydown":
											skipInputEvent = skipKeyPressEvent = !1;
											break;
										case"keypress":
											if (!0 === skipKeyPressEvent) return e.preventDefault();
											skipKeyPressEvent = !0;
											break;
										case"click":
										case"focus":
											return args = arguments, setTimeout(function () {
												eventHandler.apply(that, args)
											}, 0), !1
									}
									var returnVal = eventHandler.apply(that, arguments);
									return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal
								}
								e.preventDefault()
							}
						};
						input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), -1 !== $.inArray(eventName, ["submit", "reset"]) ? null !== input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev)
					}, off: function (input, event) {
						var events;
						input.inputmask && input.inputmask.events && (event ? (events = [])[event] = input.inputmask.events[event] : events = input.inputmask.events, $.each(events, function (eventName, evArr) {
							for (; 0 < evArr.length;) {
								var ev = evArr.pop();
								-1 !== $.inArray(eventName, ["submit", "reset"]) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev)
							}
							delete input.inputmask.events[eventName]
						}))
					}
				}, EventHandlers = {
					keydownEvent: function (e, fromInputFallback) {
						var input = this, $input = $(input), k = e.keyCode, pos = caret(input),
							kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos, opts);
						if (void 0 !== kdResult) return kdResult;
						if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported("cut")) e.preventDefault(), handleRemove(0, k, pos), writeBuffer(input, getBuffer(!0), !0 === fromInputFallback && !1 === opts.insertMode ? seekPrevious(maskset.p) : maskset.p, e, input.inputmask._valueGet() !== getBuffer().join("")); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {
							e.preventDefault();
							var caretPos = seekNext(getLastValidPosition());
							caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0)
						} else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(), caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(input, !0, !1, undoValue.split("")), $input.trigger("click")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === opts.tabThrough && k === Inputmask.keyCode.TAB ? (!0 === e.shiftKey ? (!0 === getTest(pos.begin).match.static && (pos.begin = seekNext(pos.begin)), pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0), pos.end = seekNext(pos.begin, !0), pos.end < maskset.maskLength && pos.end--), pos.begin < maskset.maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || !1 === opts.insertMode && (k === Inputmask.keyCode.RIGHT ? setTimeout(function () {
							var caretPos = caret(input);
							caret(input, caretPos.begin)
						}, 0) : k === Inputmask.keyCode.LEFT && setTimeout(function () {
							var caretPos = caret(input);
							caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1)
						}, 0)) : (opts.insertMode = !opts.insertMode, caret(input, pos.begin, pos.end));
						ignorable = -1 !== $.inArray(k, opts.ignorables)
					}, keypressEvent: function (e, checkval, writeOut, strict, ndx) {
						var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;
						if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("") && (undoValue = getBuffer().join(""), setTimeout(function () {
							$input.trigger("change")
						}, 0)), !0;
						if (k) {
							46 === k && !1 === e.shiftKey && "" !== opts.radixPoint && (k = opts.radixPoint.charCodeAt(0));
							var forwardPosition, pos = checkval ? {begin: ndx, end: ndx} : caret(input),
								c = String.fromCharCode(k);
							maskset.writeOutBuffer = !0;
							var valResult = isValid(pos, c, strict);
							if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = void 0 !== valResult.caret ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos), maskset.p = forwardPosition), forwardPosition = opts.numericInput && void 0 === valResult.caret ? seekPrevious(forwardPosition) : forwardPosition, !1 !== writeOut && (setTimeout(function () {
								opts.onKeyValidation.call(input, k, valResult, opts)
							}, 0), maskset.writeOutBuffer && !1 !== valResult)) {
								var buffer = getBuffer();
								writeBuffer(input, buffer, forwardPosition, e, !0 !== checkval)
							}
							if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), valResult
						}
					}, pasteEvent: function (e) {
						var tempValue, ev = e.originalEvent || e, inputValue = this.inputmask._valueGet(!0),
							caretPos = caret(this);
						isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
						var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
							valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
						if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("") && (valueBeforeCaret = ""), valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("") && (valueAfterCaret = ""), window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret; else {
							if (!ev.clipboardData || !ev.clipboardData.getData) return !0;
							inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret
						}
						var pasteValue = inputValue;
						if ($.isFunction(opts.onBeforePaste)) {
							if (!1 === (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts))) return e.preventDefault();
							pasteValue = pasteValue || inputValue
						}
						return checkVal(this, !1, !1, pasteValue.toString().split("")), writeBuffer(this, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join("")), e.preventDefault()
					}, inputFallBackEvent: function (e) {
						var input = this, inputValue = input.inputmask._valueGet();
						if (getBuffer().join("") !== inputValue) {
							var caretPos = caret(input);
							if (inputValue = function (input, inputValue, caretPos) {
								if (iemobile) {
									var inputChar = inputValue.replace(getBuffer().join(""), "");
									if (1 === inputChar.length) {
										var iv = inputValue.split("");
										iv.splice(caretPos.begin, 0, inputChar), inputValue = iv.join("")
									}
								}
								return inputValue
							}(0, inputValue = function (input, inputValue, caretPos) {
								return "." === inputValue.charAt(caretPos.begin - 1) && "" !== opts.radixPoint && ((inputValue = inputValue.split(""))[caretPos.begin - 1] = opts.radixPoint.charAt(0), inputValue = inputValue.join("")), inputValue
							}(0, inputValue, caretPos), caretPos), getBuffer().join("") !== inputValue) {
								var buffer = getBuffer().join(""),
									offset = !opts.numericInput && inputValue.length > buffer.length ? -1 : 0,
									frontPart = inputValue.substr(0, caretPos.begin),
									backPart = inputValue.substr(caretPos.begin),
									frontBufferPart = buffer.substr(0, caretPos.begin + offset),
									backBufferPart = buffer.substr(caretPos.begin + offset), selection = caretPos,
									entries = "", isEntry = !1;
								if (frontPart !== frontBufferPart) {
									var i,
										fpl = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length;
									for (i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;
									isEntry && (selection.begin = i - offset, entries += frontPart.slice(i, selection.end))
								}
								if (backPart !== backBufferPart && (backPart.length > backBufferPart.length ? entries += backPart.slice(0, 1) : backPart.length < backBufferPart.length && (selection.end += backBufferPart.length - backPart.length, isEntry || "" === opts.radixPoint || "" !== backPart || frontPart.charAt(selection.begin + offset - 1) !== opts.radixPoint || (selection.begin--, entries = opts.radixPoint))), writeBuffer(input, getBuffer(), {
									begin: selection.begin + offset,
									end: selection.end + offset
								}), 0 < entries.length) document.activeElement !== input && (input.focus(), caret(input, selection)), $.each(entries.split(""), function (ndx, entry) {
									var keypress = new $.Event("keypress");
									keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress)
								}); else {
									selection.begin === selection.end - 1 && (selection.begin = seekPrevious(selection.begin + 1), selection.begin === selection.end - 1 ? caret(input, selection.begin) : caret(input, selection.begin, selection.end));
									var keydown = new $.Event("keydown");
									keydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE, EventHandlers.keydownEvent.call(input, keydown, !0)
								}
								e.preventDefault()
							}
						}
					}, beforeInputEvent: function (e) {
						if (e.cancelable) {
							var keydown, keypress, input = this;
							switch (e.inputType) {
								case"insertText":
									return $.each(e.data.split(""), function (ndx, entry) {
										(keypress = new $.Event("keypress")).which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress)
									}), e.preventDefault();
								case"deleteContentBackward":
									return (keydown = new $.Event("keydown")).keyCode = Inputmask.keyCode.BACKSPACE, EventHandlers.keydownEvent.call(input, keydown), e.preventDefault();
								case"deleteContentForward":
									return (keydown = new $.Event("keydown")).keyCode = Inputmask.keyCode.DELETE, EventHandlers.keydownEvent.call(input, keydown), e.preventDefault()
							}
						}
					}, setValueEvent: function (e, argument_1, argument_2) {
						var value = e && e.detail ? e.detail[0] : argument_1;
						applyInputValue(this, value = value || this.inputmask._valueGet(!0)), (e.detail && void 0 !== e.detail[1] || void 0 !== argument_2) && caret(this, e.detail ? e.detail[1] : argument_2)
					}, focusEvent: function (e) {
						var nptValue = this.inputmask._valueGet();
						opts.showMaskOnFocus && nptValue !== getBuffer().join("") && writeBuffer(this, getBuffer(), seekNext(getLastValidPosition())), !0 !== opts.positionCaretOnTab || !1 !== mouseEnter || isComplete(getBuffer()) && -1 !== getLastValidPosition() || EventHandlers.clickEvent.apply(this, [e, !0]), undoValue = getBuffer().join("")
					}, mouseleaveEvent: function () {
						mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== this && HandleNativePlaceholder(this, originalPlaceholder)
					}, clickEvent: function (e, tabbed) {
						if (document.activeElement === this) {
							var newCaretPosition = determineNewCaretPosition(caret(this), tabbed);
							void 0 !== newCaretPosition && caret(this, newCaretPosition)
						}
					}, cutEvent: function (e) {
						var pos = caret(this), ev = e.originalEvent || e,
							clipboardData = window.clipboardData || ev.clipboardData,
							clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
						clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join("")), document.execCommand && document.execCommand("copy"), handleRemove(0, Inputmask.keyCode.DELETE, pos), writeBuffer(this, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(""))
					}, blurEvent: function (e) {
						var $input = $(this);
						if (this.inputmask) {
							HandleNativePlaceholder(this, originalPlaceholder);
							var nptValue = this.inputmask._valueGet(), buffer = getBuffer().slice();
							"" === nptValue && void 0 === colorMask || (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer)), !1 === isComplete(buffer) && (setTimeout(function () {
								$input.trigger("incomplete")
							}, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), writeBuffer(this, buffer, void 0, e)), undoValue !== getBuffer().join("") && (undoValue = getBuffer().join(""), $input.trigger("change"))
						}
					}, mouseenterEvent: function () {
						mouseEnter = !0, document.activeElement !== this && (null == originalPlaceholder && this.placeholder !== originalPlaceholder && (originalPlaceholder = this.placeholder), opts.showMaskOnHover && HandleNativePlaceholder(this, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("")))
					}, submitEvent: function () {
						undoValue !== getBuffer().join("") && $el.trigger("change"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("") && el.inputmask._valueSet(""), opts.clearIncomplete && !1 === isComplete(getBuffer()) && el.inputmask._valueSet(""), opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0), setTimeout(function () {
							writeBuffer(el, getBuffer())
						}, 0))
					}, resetEvent: function () {
						el.inputmask.refreshValue = !0, setTimeout(function () {
							applyInputValue(el, el.inputmask._valueGet(!0))
						}, 0)
					}
				};
			if (void 0 !== actionObj) switch (actionObj.action) {
				case"isComplete":
					return el = actionObj.el, isComplete(getBuffer());
				case"unmaskedvalue":
					return void 0 !== el && void 0 === actionObj.value || (valueBuffer = actionObj.value, valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer).split(""), checkVal.call(this, void 0, !1, !1, valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(inputmask, void 0, getBuffer(), 0, opts)), unmaskedvalue(el);
				case"mask":
					!function (elem) {
						EventRuler.off(elem);
						var isSupported = function (input, opts) {
							var elementType = input.getAttribute("type"),
								isSupported = "INPUT" === input.tagName && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || "TEXTAREA" === input.tagName;
							if (!isSupported) if ("INPUT" === input.tagName) {
								var el = document.createElement("input");
								el.setAttribute("type", elementType), isSupported = "text" === el.type, el = null
							} else isSupported = "partial";
							return !1 !== isSupported ? function (npt) {
								function getter() {
									return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") : valueGet.call(this) : "" : valueGet.call(this)
								}

								function setter(value) {
									valueSet.call(this, value), this.inputmask && applyInputValue(this, value)
								}

								var valueGet, valueSet;
								if (!npt.inputmask.__valueGet) {
									if (!0 !== opts.noValuePatching) {
										if (Object.getOwnPropertyDescriptor) {
											"function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === _typeof("test".__proto__) ? function (object) {
												return object.__proto__
											} : function (object) {
												return object.constructor.prototype
											});
											var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : void 0;
											valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, valueSet = valueProperty.set, Object.defineProperty(npt, "value", {
												get: getter,
												set: setter,
												configurable: !0
											})) : "INPUT" !== npt.tagName && (valueGet = function () {
												return this.textContent
											}, valueSet = function (value) {
												this.textContent = value
											}, Object.defineProperty(npt, "value", {
												get: getter,
												set: setter,
												configurable: !0
											}))
										} else document.__lookupGetter__ && npt.__lookupGetter__("value") && (valueGet = npt.__lookupGetter__("value"), valueSet = npt.__lookupSetter__("value"), npt.__defineGetter__("value", getter), npt.__defineSetter__("value", setter));
										npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet
									}
									npt.inputmask._valueGet = function (overruleRTL) {
										return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el)
									}, npt.inputmask._valueSet = function (value, overruleRTL) {
										valueSet.call(this.el, null == value ? "" : !0 !== overruleRTL && isRTL ? value.split("").reverse().join("") : value)
									}, void 0 === valueGet && (valueGet = function () {
										return this.value
									}, valueSet = function (value) {
										this.value = value
									}, function (type) {
										if ($.valHooks && (void 0 === $.valHooks[type] || !0 !== $.valHooks[type].inputmaskpatch)) {
											var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {
													return elem.value
												},
												valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {
													return elem.value = value, elem
												};
											$.valHooks[type] = {
												get: function (elem) {
													if (elem.inputmask) {
														if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();
														var result = valhookGet(elem);
														return -1 !== getLastValidPosition(void 0, void 0, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : ""
													}
													return valhookGet(elem)
												}, set: function (elem, value) {
													var result = valhookSet(elem, value);
													return elem.inputmask && applyInputValue(elem, value), result
												}, inputmaskpatch: !0
											}
										}
									}(npt.type), function (npt) {
										EventRuler.on(npt, "mouseenter", function () {
											var value = this.inputmask._valueGet(!0);
											value !== (isRTL ? getBuffer().reverse() : getBuffer()).join("") && applyInputValue(this, value)
										})
									}(npt))
								}
							}(input) : input.inputmask = void 0, isSupported
						}(elem, opts);
						if (!1 !== isSupported && ($el = $(el = elem), originalPlaceholder = el.placeholder, -1 === (maxLength = void 0 !== el ? el.maxLength : void 0) && (maxLength = void 0), !0 === opts.colorMask && initializeColorMask(el), mobile && ("inputmode" in el && (el.inputmode = opts.inputmode, el.setAttribute("inputmode", opts.inputmode)), !0 === opts.disablePredictiveText && ("autocorrect" in el ? el.autocorrect = !1 : (!0 !== opts.colorMask && initializeColorMask(el), el.type = "password"))), !0 === isSupported && (opts.showMaskOnFocus = opts.showMaskOnFocus && -1 === ["cc-number", "cc-exp"].indexOf(el.autocomplete), EventRuler.on(el, "submit", EventHandlers.submitEvent), EventRuler.on(el, "reset", EventHandlers.resetEvent), EventRuler.on(el, "blur", EventHandlers.blurEvent), EventRuler.on(el, "focus", EventHandlers.focusEvent), !0 !== opts.colorMask && (EventRuler.on(el, "click", EventHandlers.clickEvent), EventRuler.on(el, "mouseleave", EventHandlers.mouseleaveEvent), EventRuler.on(el, "mouseenter", EventHandlers.mouseenterEvent)), EventRuler.on(el, "paste", EventHandlers.pasteEvent), EventRuler.on(el, "cut", EventHandlers.cutEvent), EventRuler.on(el, "complete", opts.oncomplete), EventRuler.on(el, "incomplete", opts.onincomplete), EventRuler.on(el, "cleared", opts.oncleared), mobile || !0 === opts.inputEventOnly ? el.removeAttribute("maxLength") : (EventRuler.on(el, "keydown", EventHandlers.keydownEvent), EventRuler.on(el, "keypress", EventHandlers.keypressEvent)), EventRuler.on(el, "input", EventHandlers.inputFallBackEvent), EventRuler.on(el, "beforeinput", EventHandlers.beforeInputEvent)), EventRuler.on(el, "setvalue", EventHandlers.setValueEvent), undoValue = getBufferTemplate().join(""), "" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || document.activeElement === el)) {
							applyInputValue(el, el.inputmask._valueGet(!0));
							var buffer = getBuffer().slice();
							!1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(), opts.clearMaskOnLostFocus && document.activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)), (!1 === opts.clearMaskOnLostFocus || opts.showMaskOnFocus && document.activeElement === el || "" !== el.inputmask._valueGet(!0)) && writeBuffer(el, buffer), document.activeElement === el && caret(el, seekNext(getLastValidPosition()))
						}
					}(el);
					break;
				case"format":
					return valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value).split(""), checkVal.call(this, void 0, !0, !1, valueBuffer), actionObj.metadata ? {
						value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
						metadata: maskScope.call(this, {action: "getmetadata"}, maskset, opts)
					} : isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");
				case"isValid":
					actionObj.value ? (valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value).split(""), checkVal.call(this, void 0, !0, !1, valueBuffer)) : actionObj.value = isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");
					for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; rl < lmib && !isMask(lmib); lmib--) ;
					return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""));
				case"getemptymask":
					return getBufferTemplate().join("");
				case"remove":
					if (el && el.inputmask) {
						$.data(el, "_inputmask_opts", null), $el = $(el);
						var cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask);
						cv !== getBufferTemplate().join("") ? el.inputmask._valueSet(cv, opts.autoUnmask) : el.inputmask._valueSet(""), EventRuler.off(el), el.inputmask.colorMask && ((colorMask = el.inputmask.colorMask).removeChild(el), colorMask.parentNode.insertBefore(el, colorMask), colorMask.parentNode.removeChild(colorMask)), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value") && el.inputmask.__valueGet && Object.defineProperty(el, "value", {
							get: el.inputmask.__valueGet,
							set: el.inputmask.__valueSet,
							configurable: !0
						}) : document.__lookupGetter__ && el.__lookupGetter__("value") && el.inputmask.__valueGet && (el.__defineGetter__("value", el.inputmask.__valueGet), el.__defineSetter__("value", el.inputmask.__valueSet)), el.inputmask = void 0
					}
					return el;
				case"getmetadata":
					if ($.isArray(maskset.metadata)) {
						var maskTarget = getMaskTemplate(!0, 0, !1).join("");
						return $.each(maskset.metadata, function (ndx, mtdt) {
							if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1
						}), maskTarget
					}
					return maskset.metadata
			}
		}
	}, function (module, exports, __webpack_require__) {
		function _typeof(obj) {
			return (_typeof = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function (obj) {
				return void 0 === obj ? "undefined" : _typeof2(obj)
			} : function (obj) {
				return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : void 0 === obj ? "undefined" : _typeof2(obj)
			})(obj)
		}

		function getTokenizer(opts) {
			if (!opts.tokenizer) {
				var tokens = [];
				for (var ndx in formatCode) -1 === tokens.indexOf(ndx[0]) && tokens.push(ndx[0]);
				opts.tokenizer = "(" + tokens.join("+|") + ")+?|.", opts.tokenizer = new RegExp(opts.tokenizer, "g")
			}
			return opts.tokenizer
		}

		function parse(format, dateObjValue, opts, raw) {
			for (var match, mask = ""; match = getTokenizer(opts).exec(format);) if (void 0 === dateObjValue) if (formatCode[match[0]]) mask += "(" + formatCode[match[0]][0] + ")"; else switch (match[0]) {
				case"[":
					mask += "(";
					break;
				case"]":
					mask += ")?";
					break;
				default:
					mask += Inputmask.escapeRegex(match[0])
			} else if (formatCode[match[0]]) {
				if (!0 !== raw && formatCode[match[0]][3]) mask += formatCode[match[0]][3].call(dateObjValue.date); else formatCode[match[0]][2] ? mask += dateObjValue["raw" + formatCode[match[0]][2]] : mask += match[0]
			} else mask += match[0];
			return mask
		}

		function pad(val, len) {
			for (val = String(val), len = len || 2; val.length < len;) val = "0" + val;
			return val
		}

		function analyseMask(maskString, format, opts) {
			function setValue(dateObj, value, opts) {
				dateObj[targetProp] = function (value) {
					return value.replace(/[^0-9]/g, "0")
				}(value), dateObj["raw" + targetProp] = value, void 0 !== dateOperation && dateOperation.call(dateObj.date, "month" == targetProp ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp])
			}

			var targetProp, match, dateOperation, dateObj = {date: new Date(1, 0, 1)}, mask = maskString;
			if ("string" == typeof mask) {
				for (; match = getTokenizer(opts).exec(format);) {
					var value = mask.slice(0, match[0].length);
					formatCode.hasOwnProperty(match[0]) && (targetProp = formatCode[match[0]][2], dateOperation = formatCode[match[0]][1], setValue(dateObj, value)), mask = mask.slice(value.length)
				}
				return dateObj
			}
			if (mask && "object" === _typeof(mask) && mask.hasOwnProperty("date")) return mask
		}

		var Inputmask = __webpack_require__(3), $ = Inputmask.dependencyLib, formatCode = {
			d: ["[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate],
			dd: ["0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function () {
				return pad(Date.prototype.getDate.call(this), 2)
			}],
			ddd: [""],
			dddd: [""],
			m: ["[1-9]|1[012]", Date.prototype.setMonth, "month", function () {
				return Date.prototype.getMonth.call(this) + 1
			}],
			mm: ["0[1-9]|1[012]", Date.prototype.setMonth, "month", function () {
				return pad(Date.prototype.getMonth.call(this) + 1, 2)
			}],
			mmm: [""],
			mmmm: [""],
			yy: ["[0-9]{2}", Date.prototype.setFullYear, "year", function () {
				return pad(Date.prototype.getFullYear.call(this), 2)
			}],
			yyyy: ["[0-9]{4}", Date.prototype.setFullYear, "year", function () {
				return pad(Date.prototype.getFullYear.call(this), 4)
			}],
			h: ["[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours],
			hh: ["0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function () {
				return pad(Date.prototype.getHours.call(this), 2)
			}],
			hhh: ["[0-9]+", Date.prototype.setHours, "hours", Date.prototype.getHours],
			H: ["1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours],
			HH: ["0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function () {
				return pad(Date.prototype.getHours.call(this), 2)
			}],
			HHH: ["[0-9]+", Date.prototype.setHours, "hours", Date.prototype.getHours],
			M: ["[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes],
			MM: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function () {
				return pad(Date.prototype.getMinutes.call(this), 2)
			}],
			s: ["[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds],
			ss: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function () {
				return pad(Date.prototype.getSeconds.call(this), 2)
			}],
			l: ["[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function () {
				return pad(Date.prototype.getMilliseconds.call(this), 3)
			}],
			L: ["[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function () {
				return pad(Date.prototype.getMilliseconds.call(this), 2)
			}],
			t: ["[ap]"],
			tt: ["[ap]m"],
			T: ["[AP]"],
			TT: ["[AP]M"],
			Z: [""],
			o: [""],
			S: [""]
		}, formatAlias = {
			isoDate: "yyyy-mm-dd",
			isoTime: "HH:MM:ss",
			isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
			isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
		};
		Inputmask.extendAliases({
			datetime: {
				mask: function (opts) {
					return formatCode.S = opts.i18n.ordinalSuffix.join("|"), opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat, opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat, opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat, opts.placeholder = "" !== opts.placeholder ? opts.placeholder : opts.inputFormat.replace(/[[\]]/, ""), opts.regex = parse(opts.inputFormat, void 0, opts), null
				},
				placeholder: "",
				inputFormat: "isoDateTime",
				displayFormat: void 0,
				outputFormat: void 0,
				min: null,
				max: null,
				i18n: {
					dayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
					monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
					ordinalSuffix: ["st", "nd", "rd", "th"]
				},
				preValidation: function (buffer, pos, c, isSelection, opts, maskset) {
					var targetMatch, match, calcPos = 0;
					if (isNaN(c) && buffer[pos] !== c) {
						for (; match = getTokenizer(opts).exec(opts.inputFormat);) if (pos <= (calcPos += match[0].length)) {
							targetMatch = match, match = getTokenizer(opts).exec(opts.inputFormat);
							break
						}
						if (match && match[0] === c && 1 < targetMatch[0].length) return buffer[pos] = buffer[pos - 1], buffer[pos - 1] = "0", {
							fuzzy: !0,
							buffer: buffer,
							refreshFromBuffer: {start: pos - 1, end: pos + 1},
							pos: pos + 1
						}
					}
					return !0
				},
				postValidation: function (buffer, pos, currentResult, opts) {
					opts.min = analyseMask(opts.min, opts.inputFormat, opts), opts.max = analyseMask(opts.max, opts.inputFormat, opts), currentResult.fuzzy && (buffer = currentResult.buffer, pos = currentResult.pos);
					var result = currentResult, dateParts = analyseMask(buffer.join(""), opts.inputFormat, opts);
					return result && dateParts.date.getTime() == dateParts.date.getTime() && (result = (result = function (dateParts, currentResult) {
						return (!isFinite(dateParts.rawday) || "29" == dateParts.day && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day) && currentResult
					}(dateParts, result)) && function (dateParts, opts) {
						var result = !0;
						if (opts.min) {
							if (dateParts.rawyear) {
								var rawYear = dateParts.rawyear.replace(/[^0-9]/g, "");
								result = opts.min.year.substr(0, rawYear.length) <= rawYear
							}
							dateParts.year === dateParts.rawyear && opts.min.date.getTime() == opts.min.date.getTime() && (result = opts.min.date.getTime() <= dateParts.date.getTime())
						}
						return result && opts.max && opts.max.date.getTime() == opts.max.date.getTime() && (result = opts.max.date.getTime() >= dateParts.date.getTime()), result
					}(dateParts, opts)), pos && result && currentResult.pos !== pos ? {
						buffer: parse(opts.inputFormat, dateParts, opts),
						refreshFromBuffer: {start: pos, end: currentResult.pos}
					} : result
				},
				onKeyDown: function (e, buffer, caretPos, opts) {
					if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
						for (var match, today = new Date, date = ""; match = getTokenizer(opts).exec(opts.inputFormat);) "d" === match[0].charAt(0) ? date += pad(today.getDate(), match[0].length) : "m" === match[0].charAt(0) ? date += pad(today.getMonth() + 1, match[0].length) : "yyyy" === match[0] ? date += today.getFullYear().toString() : "y" === match[0].charAt(0) && (date += pad(today.getYear(), match[0].length));
						this.inputmask._valueSet(date), $(this).trigger("setvalue")
					}
				},
				onUnMask: function (maskedValue, unmaskedValue, opts) {
					return unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, !0) : unmaskedValue
				},
				casing: function (elem, test, pos, validPositions) {
					return 0 == test.nativeDef.indexOf("[ap]") ? elem.toLowerCase() : 0 == test.nativeDef.indexOf("[AP]") ? elem.toUpperCase() : elem
				},
				insertMode: !1,
				shiftPositions: !1,
				keepStatic: !1
			}
		}), module.exports = Inputmask
	}, function (module, exports, __webpack_require__) {
		function autoEscape(txt, opts) {
			for (var escapedTxt = "", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += "\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);
			return escapedTxt
		}

		function alignDigits(buffer, digits, opts) {
			if (0 < digits && !opts.digitsOptional && 0 < buffer.length) {
				var radixPosition = $.inArray(opts.radixPoint, buffer);
				-1 === radixPosition && (buffer.push(opts.radixPoint), radixPosition = buffer.length - 1);
				for (var i = 1; i <= digits; i++) buffer[radixPosition + i] = buffer[radixPosition + i] || "0"
			}
			return buffer
		}

		function findValidator(symbol, maskset) {
			var posNdx = 0;
			if ("+" === symbol) {
				for (posNdx in maskset.validPositions) ;
				posNdx = parseInt(posNdx)
			}
			for (var tstNdx in maskset.tests) if (posNdx <= (tstNdx = parseInt(tstNdx))) for (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) if ((void 0 === maskset.validPositions[tstNdx] || "-" === symbol) && maskset.tests[tstNdx][ndx].match.def === symbol) return tstNdx + (void 0 !== maskset.validPositions[tstNdx] && "-" !== symbol ? 1 : 0);
			return posNdx
		}

		function findValid(symbol, maskset) {
			var ret = -1;
			return $.each(maskset.validPositions, function (ndx, tst) {
				if (tst.match.def === symbol) return ret = parseInt(ndx), !1
			}), ret
		}

		function decimalValidator(chrs, maskset, pos, strict, opts) {
			var radixPos = maskset.buffer.indexOf(opts.radixPoint),
				result = -1 !== radixPos && new RegExp("[0-9１-９]").test(chrs);
			return opts._radixDance && result && null == maskset.validPositions[radixPos] ? {
				insert: {
					pos: radixPos === pos ? radixPos + 1 : radixPos,
					c: opts.radixPoint
				}, pos: pos
			} : result
		}

		var Inputmask = __webpack_require__(3), $ = Inputmask.dependencyLib;
		Inputmask.extendAliases({
			numeric: {
				mask: function (opts) {
					opts.repeat = 0, opts.groupSeparator === opts.radixPoint && opts.digits && "0" !== opts.digits && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""), " " === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0), 1 < opts.placeholder.length && (opts.placeholder = opts.placeholder.charAt(0)), "radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && (opts.positionCaretOnClick = "lvp");
					var decimalDef = "0";
					!0 === opts.numericInput && void 0 === opts.__financeInput ? (decimalDef = "1", opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick ? "lvp" : opts.positionCaretOnClick, isNaN(opts.digits) && (opts.digits = 2), opts._radixDance = !1) : (opts.__financeInput = !1, opts.numericInput = !0);
					var altMask, mask = "[+]";
					if (mask += autoEscape(opts.prefix, opts), "" !== opts.groupSeparator ? mask += opts._mask(opts) : mask += "9{+}", void 0 !== opts.digits) {
						var dq = opts.digits.toString().split(",");
						isFinite(dq[0]) && dq[1] && isFinite(dq[1]) ? mask += opts.radixPoint + decimalDef + "{" + opts.digits + "}" : (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && (opts.digitsOptional ? (altMask = mask + opts.radixPoint + decimalDef + "{0," + opts.digits + "}", opts.keepStatic = !0) : mask += opts.radixPoint + decimalDef + "{" + opts.digits + "}")
					}
					return mask += autoEscape(opts.suffix, opts), mask += "[-]", altMask && (mask = [altMask + autoEscape(opts.suffix, opts) + "[-]", mask]), opts.greedy = !1, function (opts) {
						void 0 === opts.parseMinMaxOptions && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), "," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, ".")), opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), "," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, ".")), opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), opts.parseMinMaxOptions = "done")
					}(opts), mask
				},
				_mask: function (opts) {
					return "(" + opts.groupSeparator + "999){+|1}"
				},
				placeholder: "0",
				greedy: !1,
				digits: "*",
				digitsOptional: !0,
				enforceDigitsOnBlur: !1,
				radixPoint: ".",
				positionCaretOnClick: "radixFocus",
				_radixDance: !0,
				groupSeparator: "",
				allowMinus: !0,
				negationSymbol: {front: "-", back: ""},
				prefix: "",
				suffix: "",
				rightAlign: !0,
				min: null,
				max: null,
				step: 1,
				insertMode: !0,
				autoUnmask: !1,
				unmaskAsNumber: !1,
				inputmode: "numeric",
				definitions: {
					0: {validator: decimalValidator},
					1: {validator: decimalValidator, definitionSymbol: "*"},
					"+": {
						validator: function (chrs, maskset, pos, strict, opts) {
							return opts.allowMinus && ("-" === chrs || chrs === opts.negationSymbol.front)
						}
					},
					"-": {
						validator: function (chrs, maskset, pos, strict, opts) {
							return opts.allowMinus && chrs === opts.negationSymbol.back
						}
					}
				},
				preValidation: function (buffer, pos, c, isSelection, opts, maskset, caretPos) {
					var radixPos = $.inArray(opts.radixPoint, buffer);
					if (pos = function (pos, c, radixPos, opts) {
						return opts._radixDance && opts.numericInput && c !== opts.negationSymbol.back && pos <= radixPos && (0 < radixPos || c == opts.radixPoint) && (pos -= 1), pos
					}(pos, c, radixPos, opts), "-" !== c && c !== opts.negationSymbol.front) return -1 !== radixPos && !0 === opts._radixDance && !1 === isSelection && c === opts.radixPoint && void 0 !== opts.digits && (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && radixPos !== pos ? {caret: opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos} : {rewritePosition: isSelection && caretPos.end < radixPos ? radixPos : pos};
					if (!0 !== opts.allowMinus) return !1;
					var isNegative = !1, front = findValid("+", maskset), back = findValid("-", maskset);
					return -1 !== front && (isNegative = [front, back]), !1 !== isNegative ? {
						remove: isNegative,
						caret: pos < radixPos ? pos + 1 : pos
					} : {
						insert: [{
							pos: findValidator("+", maskset),
							c: opts.negationSymbol.front,
							fromIsValid: !0
						}, {pos: findValidator("-", maskset), c: opts.negationSymbol.back, fromIsValid: void 0}],
						caret: pos < radixPos ? pos + 1 : pos
					}
				},
				postValidation: function (buffer, pos, currentResult, opts) {
					if (null !== opts.min || null !== opts.max) {
						var unmasked = opts.onUnMask(buffer.slice().reverse().join(""), void 0, $.extend({}, opts, {unmaskAsNumber: !0}));
						if (null !== opts.min && unmasked < opts.min && unmasked.toString().length >= opts.min.toString().length) return !1;
						if (null !== opts.max && unmasked > opts.max) return !1
					}
					return currentResult
				},
				onUnMask: function (maskedValue, unmaskedValue, opts) {
					if ("" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
					var processValue = maskedValue.replace(opts.prefix, "");
					return processValue = (processValue = processValue.replace(opts.suffix, "")).replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), "" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), "g"), "0")), opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".")), processValue = (processValue = processValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""), Number(processValue)) : processValue
				},
				isComplete: function (buffer, opts) {
					var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join("");
					return maskedValue = (maskedValue = (maskedValue = (maskedValue = (maskedValue = maskedValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), "")).replace(opts.prefix, "")).replace(opts.suffix, "")).replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === opts.radixPoint && (maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".")), isFinite(maskedValue)
				},
				onBeforeMask: function (initialValue, opts) {
					var radixPoint = opts.radixPoint || ",";
					"number" != typeof initialValue && "number" !== opts.inputType || "" === radixPoint || (initialValue = initialValue.toString().replace(".", radixPoint));
					var valueParts = initialValue.split(radixPoint),
						integerPart = valueParts[0].replace(/[^\-0-9]/g, ""),
						decimalPart = 1 < valueParts.length ? valueParts[1].replace(/[^0-9]/g, "") : "";
					initialValue = integerPart + ("" !== decimalPart ? radixPoint + decimalPart : decimalPart);
					var digits = 0;
					if ("" !== radixPoint && (digits = decimalPart.length, "" !== decimalPart)) {
						var digitsFactor = Math.pow(10, digits || 1);
						isFinite(opts.digits) && (digits = parseInt(opts.digits), digitsFactor = Math.pow(10, digits)), initialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), "."), isFinite(initialValue) && (initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor), initialValue = initialValue.toString().replace(".", radixPoint)
					}
					return 0 === opts.digits && -1 !== initialValue.indexOf(Inputmask.escapeRegex(radixPoint)) && (initialValue = initialValue.substring(0, initialValue.indexOf(Inputmask.escapeRegex(radixPoint)))), alignDigits(initialValue.toString().split(""), digits, opts).join("")
				},
				onBeforeWrite: function (e, buffer, caretPos, opts) {
					var result, leadingzeroes = function (buffer, opts) {
						var numberMatches = new RegExp("(^" + ("" != opts.negationSymbol.front ? Inputmask.escapeRegex(opts.negationSymbol.front) + "?" : "") + Inputmask.escapeRegex(opts.prefix) + ")(.*)(" + Inputmask.escapeRegex(opts.suffix) + ("" != opts.negationSymbol.back ? Inputmask.escapeRegex(opts.negationSymbol.back) + "?" : "") + "$)").exec(buffer.slice().reverse().join("")),
							number = numberMatches ? numberMatches[2] : "", leadingzeroes = !1;
						return number && (number = number.split(opts.radixPoint.charAt(0))[0], leadingzeroes = new RegExp("^[0" + opts.groupSeparator + "]*").exec(number)), !(!leadingzeroes || !(1 < leadingzeroes[0].length || 0 < leadingzeroes[0].length && leadingzeroes[0].length < number.length)) && leadingzeroes
					}(buffer, opts);
					if (leadingzeroes) {
						var buf = buffer.slice().reverse(), caretNdx = buf.join("").indexOf(leadingzeroes[0]);
						buf.splice(caretNdx, leadingzeroes[0].length);
						var newCaretPos = buf.length - caretNdx;
						result = {
							refreshFromBuffer: !0,
							buffer: buf.reverse(),
							caret: caretPos < newCaretPos ? caretPos : newCaretPos
						}
					}
					if (e) switch (e.type) {
						case"blur":
						case"checkval":
							"" !== opts.radixPoint && buffer[0] === opts.radixPoint && (result && result.buffer ? result.buffer.shift() : (buffer.shift(), result = {
								refreshFromBuffer: !0,
								buffer: buffer
							}))
					}
					return result
				},
				onKeyDown: function (e, buffer, caretPos, opts) {
					var $input = $(this);
					if (e.ctrlKey) switch (e.keyCode) {
						case Inputmask.keyCode.UP:
							return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue"), !1;
						case Inputmask.keyCode.DOWN:
							return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue"), !1
					}
					if (!(e.shiftKey || e.keyCode !== Inputmask.keyCode.DELETE && e.keyCode !== Inputmask.keyCode.BACKSPACE && e.keyCode !== Inputmask.keyCode.BACKSPACE_SAFARI || !0 !== opts._radixDance || opts.digitsOptional)) {
						var radixPos = $.inArray(opts.radixPoint, buffer);
						if (-1 !== radixPos && (caretPos.begin < radixPos || e.keyCode === Inputmask.keyCode.DELETE && caretPos.begin === radixPos)) {
							e.keyCode !== Inputmask.keyCode.BACKSPACE && e.keyCode !== Inputmask.keyCode.BACKSPACE_SAFARI || caretPos.begin++;
							var bffr = buffer.slice().reverse();
							return bffr.splice(bffr.length - caretPos.begin, 1), $input.trigger("setvalue", [alignDigits(bffr, opts.digits, opts).join(""), caretPos.begin]), !1
						}
					}
				}
			},
			currency: {
				prefix: "$ ",
				groupSeparator: ",",
				alias: "numeric",
				placeholder: "0",
				digits: 2,
				digitsOptional: !1
			},
			decimal: {alias: "numeric"},
			integer: {alias: "numeric", digits: 0},
			percentage: {alias: "integer", min: 0, max: 100, suffix: " %", allowMinus: !1},
			indianns: {
				alias: "numeric", _mask: function (opts) {
					return "(" + opts.groupSeparator + "99){*|1}(" + opts.groupSeparator + "999){1|1}"
				}, groupSeparator: ",", radixPoint: ".", placeholder: "0", digits: 2, digitsOptional: !1
			}
		}), module.exports = Inputmask
	}, function (module, exports, __webpack_require__) {
		function _typeof(obj) {
			return (_typeof = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function (obj) {
				return void 0 === obj ? "undefined" : _typeof2(obj)
			} : function (obj) {
				return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : void 0 === obj ? "undefined" : _typeof2(obj)
			})(obj)
		}

		var $ = __webpack_require__(5), Inputmask = __webpack_require__(3);
		void 0 === $.fn.inputmask && ($.fn.inputmask = function (fn, options) {
			var nptmask, input = this[0];
			if (void 0 === options && (options = {}), "string" == typeof fn) switch (fn) {
				case"unmaskedvalue":
					return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();
				case"remove":
					return this.each(function () {
						this.inputmask && this.inputmask.remove()
					});
				case"getemptymask":
					return input && input.inputmask ? input.inputmask.getemptymask() : "";
				case"hasMaskedValue":
					return !(!input || !input.inputmask) && input.inputmask.hasMaskedValue();
				case"isComplete":
					return !input || !input.inputmask || input.inputmask.isComplete();
				case"getmetadata":
					return input && input.inputmask ? input.inputmask.getmetadata() : void 0;
				case"setvalue":
					Inputmask.setValue(input, options);
					break;
				case"option":
					if ("string" != typeof options) return this.each(function () {
						if (void 0 !== this.inputmask) return this.inputmask.option(options)
					});
					if (input && void 0 !== input.inputmask) return input.inputmask.option(options);
					break;
				default:
					return options.alias = fn, nptmask = new Inputmask(options), this.each(function () {
						nptmask.mask(this)
					})
			} else {
				if (Array.isArray(fn)) return options.alias = fn, nptmask = new Inputmask(options), this.each(function () {
					nptmask.mask(this)
				});
				if ("object" == _typeof(fn)) return nptmask = new Inputmask(fn), void 0 === fn.mask && void 0 === fn.alias ? this.each(function () {
					if (void 0 !== this.inputmask) return this.inputmask.option(fn);
					nptmask.mask(this)
				}) : this.each(function () {
					nptmask.mask(this)
				});
				if (void 0 === fn) return this.each(function () {
					(nptmask = new Inputmask(options)).mask(this)
				})
			}
		})
	}], installedModules = {}, __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {
		__webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {enumerable: !0, get: getter})
	}, __webpack_require__.r = function (exports) {
		"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(exports, "__esModule", {value: !0})
	}, __webpack_require__.t = function (value, mode) {
		if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
		if (4 & mode && "object" == (void 0 === value ? "undefined" : _typeof2(value)) && value && value.__esModule) return value;
		var ns = Object.create(null);
		if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
			enumerable: !0,
			value: value
		}), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function (key) {
			return value[key]
		}.bind(null, key));
		return ns
	}, __webpack_require__.n = function (module) {
		var getter = module && module.__esModule ? function () {
			return module.default
		} : function () {
			return module
		};
		return __webpack_require__.d(getter, "a", getter), getter
	}, __webpack_require__.o = function (object, property) {
		return Object.prototype.hasOwnProperty.call(object, property)
	}, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 0);
	var modules, installedModules
}), function (factory) {
	"function" == typeof define && define.amd ? define(["jquery"], factory) : "object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) ? factory(require("jquery")) : factory(window.jQuery || window.Zepto)
}(function ($) {
	var mfp, _prevStatus, _document, _prevContentType, _wrapClasses, _currPopupType, MagnificPopup = function () {
	}, _isJQ = !!window.jQuery, _window = $(window), _mfpOn = function (name, f) {
		mfp.ev.on("mfp" + name + ".mfp", f)
	}, _getEl = function (className, appendTo, html, raw) {
		var el = document.createElement("div");
		return el.className = "mfp-" + className, html && (el.innerHTML = html), raw ? appendTo && appendTo.appendChild(el) : (el = $(el), appendTo && el.appendTo(appendTo)), el
	}, _mfpTrigger = function (e, data) {
		mfp.ev.triggerHandler("mfp" + e, data), mfp.st.callbacks && (e = e.charAt(0).toLowerCase() + e.slice(1), mfp.st.callbacks[e] && mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]))
	}, _getCloseBtn = function (type) {
		return type === _currPopupType && mfp.currTemplate.closeBtn || (mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace("%title%", mfp.st.tClose)), _currPopupType = type), mfp.currTemplate.closeBtn
	}, _checkInstance = function () {
		$.magnificPopup.instance || ((mfp = new MagnificPopup).init(), $.magnificPopup.instance = mfp)
	};
	MagnificPopup.prototype = {
		constructor: MagnificPopup, init: function () {
			var appVersion = navigator.appVersion;
			mfp.isLowIE = mfp.isIE8 = document.all && !document.addEventListener, mfp.isAndroid = /android/gi.test(appVersion), mfp.isIOS = /iphone|ipad|ipod/gi.test(appVersion), mfp.supportsTransition = function () {
				var s = document.createElement("p").style, v = ["ms", "O", "Moz", "Webkit"];
				if (void 0 !== s.transition) return !0;
				for (; v.length;) if (v.pop() + "Transition" in s) return !0;
				return !1
			}(), mfp.probablyMobile = mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), _document = $(document), mfp.popupsCache = {}
		}, open: function (data) {
			var i;
			if (!1 === data.isObj) {
				mfp.items = data.items.toArray(), mfp.index = 0;
				var item, items = data.items;
				for (i = 0; i < items.length; i++) if ((item = items[i]).parsed && (item = item.el[0]), item === data.el[0]) {
					mfp.index = i;
					break
				}
			} else mfp.items = $.isArray(data.items) ? data.items : [data.items], mfp.index = data.index || 0;
			if (!mfp.isOpen) {
				mfp.types = [], _wrapClasses = "", data.mainEl && data.mainEl.length ? mfp.ev = data.mainEl.eq(0) : mfp.ev = _document, data.key ? (mfp.popupsCache[data.key] || (mfp.popupsCache[data.key] = {}), mfp.currTemplate = mfp.popupsCache[data.key]) : mfp.currTemplate = {}, mfp.st = $.extend(!0, {}, $.magnificPopup.defaults, data), mfp.fixedContentPos = "auto" === mfp.st.fixedContentPos ? !mfp.probablyMobile : mfp.st.fixedContentPos, mfp.st.modal && (mfp.st.closeOnContentClick = !1, mfp.st.closeOnBgClick = !1, mfp.st.showCloseBtn = !1, mfp.st.enableEscapeKey = !1), mfp.bgOverlay || (mfp.bgOverlay = _getEl("bg").on("click.mfp", function () {
					mfp.close()
				}), mfp.wrap = _getEl("wrap").attr("tabindex", -1).on("click.mfp", function (e) {
					mfp._checkIfClose(e.target) && mfp.close()
				}), mfp.container = _getEl("container", mfp.wrap)), mfp.contentContainer = _getEl("content"), mfp.st.preloader && (mfp.preloader = _getEl("preloader", mfp.container, mfp.st.tLoading));
				var modules = $.magnificPopup.modules;
				for (i = 0; i < modules.length; i++) {
					var n = modules[i];
					n = n.charAt(0).toUpperCase() + n.slice(1), mfp["init" + n].call(mfp)
				}
				_mfpTrigger("BeforeOpen"), mfp.st.showCloseBtn && (mfp.st.closeBtnInside ? (_mfpOn("MarkupParse", function (e, template, values, item) {
					values.close_replaceWith = _getCloseBtn(item.type)
				}), _wrapClasses += " mfp-close-btn-in") : mfp.wrap.append(_getCloseBtn())), mfp.st.alignTop && (_wrapClasses += " mfp-align-top"), mfp.fixedContentPos ? mfp.wrap.css({
					overflow: mfp.st.overflowY,
					overflowX: "hidden",
					overflowY: mfp.st.overflowY
				}) : mfp.wrap.css({
					top: _window.scrollTop(),
					position: "absolute"
				}), (!1 === mfp.st.fixedBgPos || "auto" === mfp.st.fixedBgPos && !mfp.fixedContentPos) && mfp.bgOverlay.css({
					height: _document.height(),
					position: "absolute"
				}), mfp.st.enableEscapeKey && _document.on("keyup.mfp", function (e) {
					27 === e.keyCode && mfp.close()
				}), _window.on("resize.mfp", function () {
					mfp.updateSize()
				}), mfp.st.closeOnContentClick || (_wrapClasses += " mfp-auto-cursor"), _wrapClasses && mfp.wrap.addClass(_wrapClasses);
				var windowHeight = mfp.wH = _window.height(), windowStyles = {};
				if (mfp.fixedContentPos && mfp._hasScrollBar(windowHeight)) {
					var s = mfp._getScrollbarSize();
					s && (windowStyles.marginRight = s)
				}
				mfp.fixedContentPos && (mfp.isIE7 ? $("body, html").css("overflow", "hidden") : windowStyles.overflow = "hidden");
				var classesToadd = mfp.st.mainClass;
				return mfp.isIE7 && (classesToadd += " mfp-ie7"), classesToadd && mfp._addClassToMFP(classesToadd), mfp.updateItemHTML(), _mfpTrigger("BuildControls"), $("html").css(windowStyles), mfp.bgOverlay.add(mfp.wrap).prependTo(mfp.st.prependTo || $(document.body)), mfp._lastFocusedEl = document.activeElement, setTimeout(function () {
					mfp.content ? (mfp._addClassToMFP("mfp-ready"), mfp._setFocus()) : mfp.bgOverlay.addClass("mfp-ready"), _document.on("focusin.mfp", mfp._onFocusIn)
				}, 16), mfp.isOpen = !0, mfp.updateSize(windowHeight), _mfpTrigger("Open"), data
			}
			mfp.updateItemHTML()
		}, close: function () {
			mfp.isOpen && (_mfpTrigger("BeforeClose"), mfp.isOpen = !1, mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition ? (mfp._addClassToMFP("mfp-removing"), setTimeout(function () {
				mfp._close()
			}, mfp.st.removalDelay)) : mfp._close())
		}, _close: function () {
			_mfpTrigger("Close");
			var classesToRemove = "mfp-removing mfp-ready ";
			if (mfp.bgOverlay.detach(), mfp.wrap.detach(), mfp.container.empty(), mfp.st.mainClass && (classesToRemove += mfp.st.mainClass + " "), mfp._removeClassFromMFP(classesToRemove), mfp.fixedContentPos) {
				var windowStyles = {marginRight: ""};
				mfp.isIE7 ? $("body, html").css("overflow", "") : windowStyles.overflow = "", $("html").css(windowStyles)
			}
			_document.off("keyup.mfp focusin.mfp"), mfp.ev.off(".mfp"), mfp.wrap.attr("class", "mfp-wrap").removeAttr("style"), mfp.bgOverlay.attr("class", "mfp-bg"), mfp.container.attr("class", "mfp-container"), !mfp.st.showCloseBtn || mfp.st.closeBtnInside && !0 !== mfp.currTemplate[mfp.currItem.type] || mfp.currTemplate.closeBtn && mfp.currTemplate.closeBtn.detach(), mfp.st.autoFocusLast && mfp._lastFocusedEl && $(mfp._lastFocusedEl).focus(), mfp.currItem = null, mfp.content = null, mfp.currTemplate = null, mfp.prevHeight = 0, _mfpTrigger("AfterClose")
		}, updateSize: function (winHeight) {
			if (mfp.isIOS) {
				var zoomLevel = document.documentElement.clientWidth / window.innerWidth,
					height = window.innerHeight * zoomLevel;
				mfp.wrap.css("height", height), mfp.wH = height
			} else mfp.wH = winHeight || _window.height();
			mfp.fixedContentPos || mfp.wrap.css("height", mfp.wH), _mfpTrigger("Resize")
		}, updateItemHTML: function () {
			var item = mfp.items[mfp.index];
			mfp.contentContainer.detach(), mfp.content && mfp.content.detach(), item.parsed || (item = mfp.parseEl(mfp.index));
			var type = item.type;
			if (_mfpTrigger("BeforeChange", [mfp.currItem ? mfp.currItem.type : "", type]), mfp.currItem = item, !mfp.currTemplate[type]) {
				var markup = !!mfp.st[type] && mfp.st[type].markup;
				_mfpTrigger("FirstMarkupParse", markup), mfp.currTemplate[type] = !markup || $(markup)
			}
			_prevContentType && _prevContentType !== item.type && mfp.container.removeClass("mfp-" + _prevContentType + "-holder");
			var newContent = mfp["get" + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
			mfp.appendContent(newContent, type), item.preloaded = !0, _mfpTrigger("Change", item), _prevContentType = item.type, mfp.container.prepend(mfp.contentContainer), _mfpTrigger("AfterChange")
		}, appendContent: function (newContent, type) {
			(mfp.content = newContent) ? mfp.st.showCloseBtn && mfp.st.closeBtnInside && !0 === mfp.currTemplate[type] ? mfp.content.find(".mfp-close").length || mfp.content.append(_getCloseBtn()) : mfp.content = newContent : mfp.content = "", _mfpTrigger("BeforeAppend"), mfp.container.addClass("mfp-" + type + "-holder"), mfp.contentContainer.append(mfp.content)
		}, parseEl: function (index) {
			var type, item = mfp.items[index];
			if (item.tagName ? item = {el: $(item)} : (type = item.type, item = {data: item, src: item.src}), item.el) {
				for (var types = mfp.types, i = 0; i < types.length; i++) if (item.el.hasClass("mfp-" + types[i])) {
					type = types[i];
					break
				}
				item.src = item.el.attr("data-mfp-src"), item.src || (item.src = item.el.attr("href"))
			}
			return item.type = type || mfp.st.type || "inline", item.index = index, item.parsed = !0, mfp.items[index] = item, _mfpTrigger("ElementParse", item), mfp.items[index]
		}, addGroup: function (el, options) {
			var eHandler = function (e) {
				e.mfpEl = this, mfp._openClick(e, el, options)
			};
			options || (options = {});
			var eName = "click.magnificPopup";
			options.mainEl = el, options.items ? (options.isObj = !0, el.off(eName).on(eName, eHandler)) : (options.isObj = !1, options.delegate ? el.off(eName).on(eName, options.delegate, eHandler) : (options.items = el).off(eName).on(eName, eHandler))
		}, _openClick: function (e, el, options) {
			if ((void 0 !== options.midClick ? options.midClick : $.magnificPopup.defaults.midClick) || !(2 === e.which || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey)) {
				var disableOn = void 0 !== options.disableOn ? options.disableOn : $.magnificPopup.defaults.disableOn;
				if (disableOn) if ($.isFunction(disableOn)) {
					if (!disableOn.call(mfp)) return !0
				} else if (_window.width() < disableOn) return !0;
				e.type && (e.preventDefault(), mfp.isOpen && e.stopPropagation()), options.el = $(e.mfpEl), options.delegate && (options.items = el.find(options.delegate)), mfp.open(options)
			}
		}, updateStatus: function (status, text) {
			if (mfp.preloader) {
				_prevStatus !== status && mfp.container.removeClass("mfp-s-" + _prevStatus), text || "loading" !== status || (text = mfp.st.tLoading);
				var data = {status: status, text: text};
				_mfpTrigger("UpdateStatus", data), status = data.status, text = data.text, mfp.preloader.html(text), mfp.preloader.find("a").on("click", function (e) {
					e.stopImmediatePropagation()
				}), mfp.container.addClass("mfp-s-" + status), _prevStatus = status
			}
		}, _checkIfClose: function (target) {
			if (!$(target).hasClass("mfp-prevent-close")) {
				var closeOnContent = mfp.st.closeOnContentClick, closeOnBg = mfp.st.closeOnBgClick;
				if (closeOnContent && closeOnBg) return !0;
				if (!mfp.content || $(target).hasClass("mfp-close") || mfp.preloader && target === mfp.preloader[0]) return !0;
				if (target === mfp.content[0] || $.contains(mfp.content[0], target)) {
					if (closeOnContent) return !0
				} else if (closeOnBg && $.contains(document, target)) return !0;
				return !1
			}
		}, _addClassToMFP: function (cName) {
			mfp.bgOverlay.addClass(cName), mfp.wrap.addClass(cName)
		}, _removeClassFromMFP: function (cName) {
			this.bgOverlay.removeClass(cName), mfp.wrap.removeClass(cName)
		}, _hasScrollBar: function (winHeight) {
			return (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height())
		}, _setFocus: function () {
			(mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus()
		}, _onFocusIn: function (e) {
			if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) return mfp._setFocus(), !1
		}, _parseMarkup: function (template, values, item) {
			var arr;
			item.data && (values = $.extend(item.data, values)), _mfpTrigger("MarkupParse", [template, values, item]), $.each(values, function (key, value) {
				if (void 0 === value || !1 === value) return !0;
				if (1 < (arr = key.split("_")).length) {
					var el = template.find(".mfp-" + arr[0]);
					if (0 < el.length) {
						var attr = arr[1];
						"replaceWith" === attr ? el[0] !== value[0] && el.replaceWith(value) : "img" === attr ? el.is("img") ? el.attr("src", value) : el.replaceWith($("<img>").attr("src", value).attr("class", el.attr("class"))) : el.attr(arr[1], value)
					}
				} else template.find(".mfp-" + key).html(value)
			})
		}, _getScrollbarSize: function () {
			if (void 0 === mfp.scrollbarSize) {
				var scrollDiv = document.createElement("div");
				scrollDiv.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;", document.body.appendChild(scrollDiv), mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth, document.body.removeChild(scrollDiv)
			}
			return mfp.scrollbarSize
		}
	}, $.magnificPopup = {
		instance: null,
		proto: MagnificPopup.prototype,
		modules: [],
		open: function (options, index) {
			return _checkInstance(), (options = options ? $.extend(!0, {}, options) : {}).isObj = !0, options.index = index || 0, this.instance.open(options)
		},
		close: function () {
			return $.magnificPopup.instance && $.magnificPopup.instance.close()
		},
		registerModule: function (name, module) {
			module.options && ($.magnificPopup.defaults[name] = module.options), $.extend(this.proto, module.proto), this.modules.push(name)
		},
		defaults: {
			disableOn: 0,
			key: null,
			midClick: !1,
			mainClass: "",
			preloader: !0,
			focus: "",
			closeOnContentClick: !1,
			closeOnBgClick: !0,
			closeBtnInside: !0,
			showCloseBtn: !0,
			enableEscapeKey: !0,
			modal: !1,
			alignTop: !1,
			removalDelay: 0,
			prependTo: null,
			fixedContentPos: "auto",
			fixedBgPos: "auto",
			overflowY: "auto",
			closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',
			tClose: "Close (Esc)",
			tLoading: "Loading...",
			autoFocusLast: !0
		}
	}, $.fn.magnificPopup = function (options) {
		_checkInstance();
		var jqEl = $(this);
		if ("string" == typeof options) if ("open" === options) {
			var items, itemOpts = _isJQ ? jqEl.data("magnificPopup") : jqEl[0].magnificPopup,
				index = parseInt(arguments[1], 10) || 0;
			itemOpts.items ? items = itemOpts.items[index] : (items = jqEl, itemOpts.delegate && (items = items.find(itemOpts.delegate)), items = items.eq(index)), mfp._openClick({mfpEl: items}, jqEl, itemOpts)
		} else mfp.isOpen && mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1)); else options = $.extend(!0, {}, options), _isJQ ? jqEl.data("magnificPopup", options) : jqEl[0].magnificPopup = options, mfp.addGroup(jqEl, options);
		return jqEl
	};
	var _hiddenClass, _inlinePlaceholder, _lastInlineElement, _putInlineElementsBack = function () {
		_lastInlineElement && (_inlinePlaceholder.after(_lastInlineElement.addClass(_hiddenClass)).detach(), _lastInlineElement = null)
	};
	$.magnificPopup.registerModule("inline", {
		options: {
			hiddenClass: "hide",
			markup: "",
			tNotFound: "Content not found"
		}, proto: {
			initInline: function () {
				mfp.types.push("inline"), _mfpOn("Close.inline", function () {
					_putInlineElementsBack()
				})
			}, getInline: function (item, template) {
				if (_putInlineElementsBack(), item.src) {
					var inlineSt = mfp.st.inline, el = $(item.src);
					if (el.length) {
						var parent = el[0].parentNode;
						parent && parent.tagName && (_inlinePlaceholder || (_hiddenClass = inlineSt.hiddenClass, _inlinePlaceholder = _getEl(_hiddenClass), _hiddenClass = "mfp-" + _hiddenClass), _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass)), mfp.updateStatus("ready")
					} else mfp.updateStatus("error", inlineSt.tNotFound), el = $("<div>");
					return item.inlineElement = el
				}
				return mfp.updateStatus("ready"), mfp._parseMarkup(template, {}, item), template
			}
		}
	});
	var _ajaxCur, _removeAjaxCursor = function () {
		_ajaxCur && $(document.body).removeClass(_ajaxCur)
	}, _destroyAjaxRequest = function () {
		_removeAjaxCursor(), mfp.req && mfp.req.abort()
	};
	$.magnificPopup.registerModule("ajax", {
		options: {
			settings: null,
			cursor: "mfp-ajax-cur",
			tError: '<a href="%url%">The content</a> could not be loaded.'
		}, proto: {
			initAjax: function () {
				mfp.types.push("ajax"), _ajaxCur = mfp.st.ajax.cursor, _mfpOn("Close.ajax", _destroyAjaxRequest), _mfpOn("BeforeChange.ajax", _destroyAjaxRequest)
			}, getAjax: function (item) {
				_ajaxCur && $(document.body).addClass(_ajaxCur), mfp.updateStatus("loading");
				var opts = $.extend({
					url: item.src, success: function (data, textStatus, jqXHR) {
						var temp = {data: data, xhr: jqXHR};
						_mfpTrigger("ParseAjax", temp), mfp.appendContent($(temp.data), "ajax"), item.finished = !0, _removeAjaxCursor(), mfp._setFocus(), setTimeout(function () {
							mfp.wrap.addClass("mfp-ready")
						}, 16), mfp.updateStatus("ready"), _mfpTrigger("AjaxContentAdded")
					}, error: function () {
						_removeAjaxCursor(), item.finished = item.loadError = !0, mfp.updateStatus("error", mfp.st.ajax.tError.replace("%url%", item.src))
					}
				}, mfp.st.ajax.settings);
				return mfp.req = $.ajax(opts), ""
			}
		}
	});
	var _imgInterval;
	$.magnificPopup.registerModule("image", {
		options: {
			markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>',
			cursor: "mfp-zoom-out-cur",
			titleSrc: "title",
			verticalFit: !0,
			tError: '<a href="%url%">The image</a> could not be loaded.'
		}, proto: {
			initImage: function () {
				var imgSt = mfp.st.image, ns = ".image";
				mfp.types.push("image"), _mfpOn("Open" + ns, function () {
					"image" === mfp.currItem.type && imgSt.cursor && $(document.body).addClass(imgSt.cursor)
				}), _mfpOn("Close" + ns, function () {
					imgSt.cursor && $(document.body).removeClass(imgSt.cursor), _window.off("resize.mfp")
				}), _mfpOn("Resize" + ns, mfp.resizeImage), mfp.isLowIE && _mfpOn("AfterChange", mfp.resizeImage)
			}, resizeImage: function () {
				var item = mfp.currItem;
				if (item && item.img && mfp.st.image.verticalFit) {
					var decr = 0;
					mfp.isLowIE && (decr = parseInt(item.img.css("padding-top"), 10) + parseInt(item.img.css("padding-bottom"), 10)), item.img.css("max-height", mfp.wH - decr)
				}
			}, _onImageHasSize: function (item) {
				item.img && (item.hasSize = !0, _imgInterval && clearInterval(_imgInterval), item.isCheckingImgSize = !1, _mfpTrigger("ImageHasSize", item), item.imgHidden && (mfp.content && mfp.content.removeClass("mfp-loading"), item.imgHidden = !1))
			}, findImageSize: function (item) {
				var counter = 0, img = item.img[0];
				!function mfpSetInterval(delay) {
					_imgInterval && clearInterval(_imgInterval), _imgInterval = setInterval(function () {
						0 < img.naturalWidth ? mfp._onImageHasSize(item) : (200 < counter && clearInterval(_imgInterval), 3 == ++counter ? mfpSetInterval(10) : 40 === counter ? mfpSetInterval(50) : 100 === counter && mfpSetInterval(500))
					}, delay)
				}(1)
			}, getImage: function (item, template) {
				var guard = 0, onLoadError = function () {
					item && (item.img.off(".mfploader"), item === mfp.currItem && (mfp._onImageHasSize(item), mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src))), item.hasSize = !0, item.loaded = !0, item.loadError = !0)
				}, imgSt = mfp.st.image, el = template.find(".mfp-img");
				if (el.length) {
					var img = document.createElement("img");
					img.className = "mfp-img", item.el && item.el.find("img").length && (img.alt = item.el.find("img").attr("alt")), item.img = $(img).on("load.mfploader", function onLoadComplete() {
						item && (item.img[0].complete ? (item.img.off(".mfploader"), item === mfp.currItem && (mfp._onImageHasSize(item), mfp.updateStatus("ready")), item.hasSize = !0, item.loaded = !0, _mfpTrigger("ImageLoadComplete")) : ++guard < 200 ? setTimeout(onLoadComplete, 100) : onLoadError())
					}).on("error.mfploader", onLoadError), img.src = item.src, el.is("img") && (item.img = item.img.clone()), 0 < (img = item.img[0]).naturalWidth ? item.hasSize = !0 : img.width || (item.hasSize = !1)
				}
				return mfp._parseMarkup(template, {
					title: function (item) {
						if (item.data && void 0 !== item.data.title) return item.data.title;
						var src = mfp.st.image.titleSrc;
						if (src) {
							if ($.isFunction(src)) return src.call(mfp, item);
							if (item.el) return item.el.attr(src) || ""
						}
						return ""
					}(item), img_replaceWith: item.img
				}, item), mfp.resizeImage(), item.hasSize ? (_imgInterval && clearInterval(_imgInterval), item.loadError ? (template.addClass("mfp-loading"), mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src))) : (template.removeClass("mfp-loading"), mfp.updateStatus("ready"))) : (mfp.updateStatus("loading"), item.loading = !0, item.hasSize || (item.imgHidden = !0, template.addClass("mfp-loading"), mfp.findImageSize(item))), template
			}
		}
	});
	var hasMozTransform;
	$.magnificPopup.registerModule("zoom", {
		options: {
			enabled: !1, easing: "ease-in-out", duration: 300, opener: function (element) {
				return element.is("img") ? element : element.find("img")
			}
		}, proto: {
			initZoom: function () {
				var image, zoomSt = mfp.st.zoom, ns = ".zoom";
				if (zoomSt.enabled && mfp.supportsTransition) {
					var openTimeout, animatedImg, duration = zoomSt.duration, getElToAnimate = function (image) {
						var newImg = image.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"),
							transition = "all " + zoomSt.duration / 1e3 + "s " + zoomSt.easing, cssObj = {
								position: "fixed",
								zIndex: 9999,
								left: 0,
								top: 0,
								"-webkit-backface-visibility": "hidden"
							}, t = "transition";
						return cssObj["-webkit-" + t] = cssObj["-moz-" + t] = cssObj["-o-" + t] = cssObj[t] = transition, newImg.css(cssObj), newImg
					}, showMainContent = function () {
						mfp.content.css("visibility", "visible")
					};
					_mfpOn("BuildControls" + ns, function () {
						if (mfp._allowZoom()) {
							if (clearTimeout(openTimeout), mfp.content.css("visibility", "hidden"), !(image = mfp._getItemToZoom())) return void showMainContent();
							(animatedImg = getElToAnimate(image)).css(mfp._getOffset()), mfp.wrap.append(animatedImg), openTimeout = setTimeout(function () {
								animatedImg.css(mfp._getOffset(!0)), openTimeout = setTimeout(function () {
									showMainContent(), setTimeout(function () {
										animatedImg.remove(), image = animatedImg = null, _mfpTrigger("ZoomAnimationEnded")
									}, 16)
								}, duration)
							}, 16)
						}
					}), _mfpOn("BeforeClose" + ns, function () {
						if (mfp._allowZoom()) {
							if (clearTimeout(openTimeout), mfp.st.removalDelay = duration, !image) {
								if (!(image = mfp._getItemToZoom())) return;
								animatedImg = getElToAnimate(image)
							}
							animatedImg.css(mfp._getOffset(!0)), mfp.wrap.append(animatedImg), mfp.content.css("visibility", "hidden"), setTimeout(function () {
								animatedImg.css(mfp._getOffset())
							}, 16)
						}
					}), _mfpOn("Close" + ns, function () {
						mfp._allowZoom() && (showMainContent(), animatedImg && animatedImg.remove(), image = null)
					})
				}
			}, _allowZoom: function () {
				return "image" === mfp.currItem.type
			}, _getItemToZoom: function () {
				return !!mfp.currItem.hasSize && mfp.currItem.img
			}, _getOffset: function (isLarge) {
				var el,
					offset = (el = isLarge ? mfp.currItem.img : mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem)).offset(),
					paddingTop = parseInt(el.css("padding-top"), 10),
					paddingBottom = parseInt(el.css("padding-bottom"), 10);
				offset.top -= $(window).scrollTop() - paddingTop;
				var obj = {
					width: el.width(),
					height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
				};
				return void 0 === hasMozTransform && (hasMozTransform = void 0 !== document.createElement("p").style.MozTransform), hasMozTransform ? obj["-moz-transform"] = obj.transform = "translate(" + offset.left + "px," + offset.top + "px)" : (obj.left = offset.left, obj.top = offset.top), obj
			}
		}
	});
	var _fixIframeBugs = function (isShowing) {
		if (mfp.currTemplate.iframe) {
			var el = mfp.currTemplate.iframe.find("iframe");
			el.length && (isShowing || (el[0].src = "//about:blank"), mfp.isIE8 && el.css("display", isShowing ? "block" : "none"))
		}
	};
	$.magnificPopup.registerModule("iframe", {
		options: {
			markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>',
			srcAction: "iframe_src",
			patterns: {
				youtube: {index: "youtube.com", id: "v=", src: "//www.youtube.com/embed/%id%?autoplay=1"},
				vimeo: {index: "vimeo.com/", id: "/", src: "//player.vimeo.com/video/%id%?autoplay=1"},
				gmaps: {index: "//maps.google.", src: "%id%&output=embed"}
			}
		}, proto: {
			initIframe: function () {
				mfp.types.push("iframe"), _mfpOn("BeforeChange", function (e, prevType, newType) {
					prevType !== newType && ("iframe" === prevType ? _fixIframeBugs() : "iframe" === newType && _fixIframeBugs(!0))
				}), _mfpOn("Close.iframe", function () {
					_fixIframeBugs()
				})
			}, getIframe: function (item, template) {
				var embedSrc = item.src, iframeSt = mfp.st.iframe;
				$.each(iframeSt.patterns, function () {
					if (-1 < embedSrc.indexOf(this.index)) return this.id && (embedSrc = "string" == typeof this.id ? embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length) : this.id.call(this, embedSrc)), embedSrc = this.src.replace("%id%", embedSrc), !1
				});
				var dataObj = {};
				return iframeSt.srcAction && (dataObj[iframeSt.srcAction] = embedSrc), mfp._parseMarkup(template, dataObj, item), mfp.updateStatus("ready"), template
			}
		}
	});
	var _getLoopedId = function (index) {
		var numSlides = mfp.items.length;
		return numSlides - 1 < index ? index - numSlides : index < 0 ? numSlides + index : index
	}, _replaceCurrTotal = function (text, curr, total) {
		return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total)
	};
	$.magnificPopup.registerModule("gallery", {
		options: {
			enabled: !1,
			arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
			preload: [0, 2],
			navigateByImgClick: !0,
			arrows: !0,
			tPrev: "Previous (Left arrow key)",
			tNext: "Next (Right arrow key)",
			tCounter: "%curr% of %total%"
		}, proto: {
			initGallery: function () {
				var gSt = mfp.st.gallery, ns = ".mfp-gallery";
				if (mfp.direction = !0, !gSt || !gSt.enabled) return !1;
				_wrapClasses += " mfp-gallery", _mfpOn("Open" + ns, function () {
					gSt.navigateByImgClick && mfp.wrap.on("click" + ns, ".mfp-img", function () {
						if (1 < mfp.items.length) return mfp.next(), !1
					}), _document.on("keydown" + ns, function (e) {
						37 === e.keyCode ? mfp.prev() : 39 === e.keyCode && mfp.next()
					})
				}), _mfpOn("UpdateStatus" + ns, function (e, data) {
					data.text && (data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length))
				}), _mfpOn("MarkupParse" + ns, function (e, element, values, item) {
					var l = mfp.items.length;
					values.counter = 1 < l ? _replaceCurrTotal(gSt.tCounter, item.index, l) : ""
				}), _mfpOn("BuildControls" + ns, function () {
					if (1 < mfp.items.length && gSt.arrows && !mfp.arrowLeft) {
						var markup = gSt.arrowMarkup,
							arrowLeft = mfp.arrowLeft = $(markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, "left")).addClass("mfp-prevent-close"),
							arrowRight = mfp.arrowRight = $(markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, "right")).addClass("mfp-prevent-close");
						arrowLeft.click(function () {
							mfp.prev()
						}), arrowRight.click(function () {
							mfp.next()
						}), mfp.container.append(arrowLeft.add(arrowRight))
					}
				}), _mfpOn("Change" + ns, function () {
					mfp._preloadTimeout && clearTimeout(mfp._preloadTimeout), mfp._preloadTimeout = setTimeout(function () {
						mfp.preloadNearbyImages(), mfp._preloadTimeout = null
					}, 16)
				}), _mfpOn("Close" + ns, function () {
					_document.off(ns), mfp.wrap.off("click" + ns), mfp.arrowRight = mfp.arrowLeft = null
				})
			}, next: function () {
				mfp.direction = !0, mfp.index = _getLoopedId(mfp.index + 1), mfp.updateItemHTML()
			}, prev: function () {
				mfp.direction = !1, mfp.index = _getLoopedId(mfp.index - 1), mfp.updateItemHTML()
			}, goTo: function (newIndex) {
				mfp.direction = newIndex >= mfp.index, mfp.index = newIndex, mfp.updateItemHTML()
			}, preloadNearbyImages: function () {
				var i, p = mfp.st.gallery.preload, preloadBefore = Math.min(p[0], mfp.items.length),
					preloadAfter = Math.min(p[1], mfp.items.length);
				for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) mfp._preloadItem(mfp.index + i);
				for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) mfp._preloadItem(mfp.index - i)
			}, _preloadItem: function (index) {
				if (index = _getLoopedId(index), !mfp.items[index].preloaded) {
					var item = mfp.items[index];
					item.parsed || (item = mfp.parseEl(index)), _mfpTrigger("LazyLoad", item), "image" === item.type && (item.img = $('<img class="mfp-img" />').on("load.mfploader", function () {
						item.hasSize = !0
					}).on("error.mfploader", function () {
						item.hasSize = !0, item.loadError = !0, _mfpTrigger("LazyLoadError", item)
					}).attr("src", item.src)), item.preloaded = !0
				}
			}
		}
	});
	$.magnificPopup.registerModule("retina", {
		options: {
			replaceSrc: function (item) {
				return item.src.replace(/\.\w+$/, function (m) {
					return "@2x" + m
				})
			}, ratio: 1
		}, proto: {
			initRetina: function () {
				if (1 < window.devicePixelRatio) {
					var st = mfp.st.retina, ratio = st.ratio;
					1 < (ratio = isNaN(ratio) ? ratio() : ratio) && (_mfpOn("ImageHasSize.retina", function (e, item) {
						item.img.css({"max-width": item.img[0].naturalWidth / ratio, width: "100%"})
					}), _mfpOn("ElementParse.retina", function (e, item) {
						item.src = st.replaceSrc(item, ratio)
					}))
				}
			}
		}
	}), _checkInstance()
});